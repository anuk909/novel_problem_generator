{"task_id": "hard/5", "prompt": "def enchanted_staircase(n):\n    \"\"\"\n    In an enchanted forest, there's a wise old tree that has a mystical staircase which can have n steps (n being any integer from 1 up to and including 50). Each of the steps might contain certain ancient symbols carved onto it. Each symbol manifests based on the step path taken: either 'leaf' if one step is taken or 'owl' if two steps are taken. To ascend the staircase and gain the wisdom of the wise old tree, one must follow specific rules based on these symbols. \n\n    A traveler can take either 1 or 2 steps at a time. However, the staircase has a magical memory that tracks the last two symbols for each individual step. If anywhere on the staircase the sequence [owl, leaf] appears consecutively on the same step, the staircase collapses, and the journey ends.\n\n    The function should return the total number of distinct ways to ascend the staircase such that it doesn't collapse. As input, you're given the integer n, representing the total number of steps in the staircase.\n\n    Example:\n    - For n = 3, the output should be 3. The valid paths up to the third step are: [leaf, leaf, leaf], [leaf, owl], [owl, leaf]\n    - For n = 4, the output should be 3. The valid paths up to the fourth step are: [leaf, leaf, leaf, leaf], [leaf, leaf, owl], [leaf, owl, leaf].\n\n    Note:\n    - Your algorithm should ensure that paths consisting of [leaf, leaf] or [owl, owl] should be avoided as they can also cause a collapse according to more stringent conditions defined.\n    \"\"\"\n", "canonical_solution": "    def enchanted_staircase(n):\n        if n == 0 or n == 1: return 1\n        dp = [0] * (n+1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, n+1):\n            dp[i] = dp[i-1] + dp[i-2] - (i > 3 and dp[i-4])\n        return dp[n]", "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 1\n    assert candidate(3) == 3\n    assert candidate(4) == 3\n    assert candidate(5) == 4\n    assert candidate(8) == 9\n    assert candidate(12) == 16\n    assert candidate(20) == 61\n    assert candidate(30) == 180\n    assert candidate(50) == 1255", "entry_point": "enchanted_staircase", "extra_info": {"cover_story_words": ["enchanted forest", "wise old tree"], "topics": ["Climbing Stairs", "Dynamic Programming"], "field": "", "cleaned_prompt": "Write a function enchanted_staircase(n) that calculates the distinct methods to climb a staircase of n steps without causing it to collapse, considering symbolic generation based on steps taken and sequences that lead to collapsing. Each step generates a 'leaf' if moved by one step or an 'owl' if moved by two steps.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, contradictory_rules: The problem statement contains contradicting rules regarding which sequences cause the staircase to collapse. Initially, it states that the sequence [owl, leaf] specifically causes a collapse, but later expands this to include [leaf, leaf] and [owl, owl] without clear justification or alignment with the earlier part of the problem description.", "5, incorrect_example: The example provided in the problem description is incorrect based on the rules stated. For n = 4, the output provided is 3, stating that [leaf, owl, leaf] is a valid path, but according to the rule that [owl, leaf] causes collapse, this should not be a valid sequence.", "4, unclear_task_specification: The problem statement sets a rule that a sequence [owl, leaf] causes collapse when on the same step, which is confusing because the narrative about steps involves sequential progress, not simultaneous occupancy of a step by different symbols."]}}
{"task_id": "hard/8", "prompt": "def enchanted_library(codex, magic_sum):\n    \"\"\"\n    On a distant space station, there exists an enchanted library that contains a collection of magical books. Each book in the library has a mystical number associated with it. You are given a list codex that contains the mystical numbers of all books in the library and a magical number magic_sum. Every time a new astronaut arrives at the station, they must perform a ritual by choosing a combination of books such that the sum of the mystical numbers of the selected books equals magic_sum.\n\n    Write a function that returns all possible unique combinations of mystical numbers from the codex (in any order) that sum to magic_sum. Each combination should be a list of numbers, and combinations may include the same number multiple times if it appears multiple times in the codex list.\n\n    Example:\n    - If the input is codex = [2,3,6,7] and magic_sum = 7, the output should be [[7], [2,2,3]] because the possible combinations to get a sum of 7 are [7] and [2,2,3].\n\n    Note:\n    - The result list should not contain any duplicate combinations.\n    - Combination can be in any order.\n    - If no combination can be found that adds up to magic_sum, return an empty list.\n    \"\"\"\n", "canonical_solution": "    def comb_sum(candidates, target, current, start, result):\n        if target == 0:\n            result.append(current[:])\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            comb_sum(candidates, target - candidates[i], current, i, result)\n            current.pop()\n\n    result = []\n    comb_sum(codex, magic_sum, [], 0, result)\n    return result", "test": "def check(candidate):\n    assert sorted(candidate([2, 3, 6, 7], 7)) == sorted([[7], [2, 2, 3]])\n    assert sorted(candidate([2, 2, 4, 6], 8)) == sorted([[2, 2, 2, 2], [2, 6]])\n    assert candidate([5], 5) == [[5]]\n    assert candidate([4, 3, 7], 2) == []\n    assert sorted(candidate([1, 1, 2, 5, 6], 6)) == sorted([[1, 1, 2, 2], [6]])", "entry_point": "enchanted_library", "extra_info": {"cover_story_words": ["enchanted book", "space station"], "topics": ["Combination Sum"], "field": "", "cleaned_prompt": "Write a function that takes a list of integers `codex`, representing mystical numbers associated with books, and an integer `magic_sum`. The function should return all unique combinations of numbers from `codex` that sum to `magic_sum`. Each combination should be a list of integers. Consider duplicates in `codex`, and combinations can be in any order. If no valid combination exists, return an empty list.\n\nExample:\n- For `codex = [2,3,6,7]` and `magic_sum = 7`, the output should be `[[7], [2,2,3]]`.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Incorrect Output in Test Cases: The test cases provided in the problem description and the specifications of the canonical solution do not accurately produce unique combinations as required by the prompt. Specifically, the example with input `test([1, 1, 2, 5, 6], 6)` should not include `[1, 1, 2, 2]` since having two '2's does not match the content of the codex list `[1, 1, 2, 5, 6]`; thus, there is only one '2' available. Therefore, the test case contradicts the stated capabilities of the function, which should respect the duplicate count of elements present in `codex`.", "5, Ambiguity in Combination Generation: The problem statement specifies the function should account for each number's frequency in `codex` when creating combinations. However, it does not clearly specify whether the same number can be reused unlimited times if it is present in the list multiple times. This ambiguity can lead to different implementations, impacting the uniformity and validity of the expected results across various solutions.", "4, Test Cases May Fail on Proper Implementation: The provided test function assumes a specific sorting of the output, which might not align with different but correct implementations based on the ambiguous problem statement concerning order. If combinations are supposed to be unique and order within them is not supposed to matter, the test should account for this rather than impose an unnatural sorting for validation."]}}
{"task_id": "hard/10", "prompt": "def pirate_treasure(combination_weights, capacity):\n    \"\"\"\n    A pirate discovers a cave filled with treasure chests, each filled with gold coins of different weights. The cave has an ancient security system where exceeding a total weight limit triggers deadly traps. The challenge is to determine the maximum weight of gold coins that can be extracted without activating these traps.\n\n    Given an array of integers representing the weight of gold coins in each chest and an integer 'capacity' representing the maximum allowable weight, return the maximum weight of coins that can be carried without surpassing the capacity. You must achieve this by using each chest only once.\n\n    Example:\n    - If `combination_weights` = [2, 3, 5, 7] and `capacity` = 10, the correct output should be 10 because the combinations `2 + 3 + 5` maximize the total weight.\n    - If `combination_weights` = [1, 2, 3, 4] and `capacity` = 5, the optimal load is 5 because you can use `1 + 4`.\n    - If `combination_weights` = [1, 5, 10, 11] and `capacity` = 20, the best choice results in 16 by using `5 + 11`.\n\n    Note:\n    - Each weight represents a distinct chest. Chests can be used in combination as long as the total weight does not exceed the capacity.\n    \"\"\"\n", "canonical_solution": "    def optimal_coin_load(weights, limit):\n        if not weights:\n            return 0\n        dp = [0] * (limit + 1)\n        for w in weights:\n            for j in range(limit, w - 1, -1):\n                dp[j] = max(dp[j], dp[j - w] + w)\n        return dp[limit]\n    return optimal_coin_load(combination_weights, capacity)", "test": "def check(candidate):\n    assert candidate([2, 3, 5, 7], 10) == 10\n    assert candidate([1, 2, 3, 4], 5) == 5\n    assert candidate([1, 5, 10, 11], 20) == 16\n    assert candidate([1, 3, 4, 5], 7) == 7\n    assert candidate([10, 10, 10, 10], 5) == 0\n    assert candidate([], 50) == 0\n    assert candidate([1, 2, 3, 4, 5], 0) == 0", "entry_point": "pirate_treasure", "extra_info": {"cover_story_words": ["pirate ship", "ancient security system", "traps"], "topics": ["Dynamic Programming", "Subset Sum"], "field": "", "cleaned_prompt": {"function_definition": "def pirate_treasure(combination_weights, capacity):\n", "explanation": "Given weights of gold coins in treasure chests and a maximum carrying capacity, calculate the maximum total weight of coins that can be taken without exceeding the capacity, each chest can be used not more than once.\n", "examples": {"example_1": {"combination_weights": [2, 3, 5, 7], "capacity": 10, "output": 10}, "example_2": {"combination_weights": [1, 2, 3, 4], "capacity": 5, "output": 5}, "example_3": {"combination_weights": [1, 5, 10, 11], "capacity": 20, "output": 16}}}, "warnings": ["Solution failed correctness check. reason: failed: ", "5, Mismatch Between Entry Point and Solution Method: The entry point is defined as 'pirate_treasure', but the 'canonical_solution' is using a different function name 'optimal_coin_load'. This will cause the function to not be invoked properly and the problem will be unsolvable without externally defining 'pirate_treasure' in the correct form.", "5, Incorrect Solution Implementation in Problem Statement: The solution provided in 'canonical_solution' is defined with an inline 'optimal_coin_load' function but returns 'optimal_coin_load' as if it was declared outside. This results in incorrect function return scope which could lead to a runtime error of referencing an undefined function. The correct implementation needs to correct the return scope."]}}
{"task_id": "hard/6", "prompt": "def enchanted_instrument_success_probability(events):\n    \"\"\"\n    On a mystical farm, there is an enchanted musical instrument that plays a special song to boost crop growth. The efficiency of the song each day is determined by a sequence of probabilistic events, which form a dependency chain.\n\n    Each event in the sequence can be represented by:\n    - An identifier (a distinct integer).\n    - A list of tuples, where each tuple contains:\n        1. The identifier of a dependent event.\n        2. The conditional probability (a float between 0 and 1) that this specific event succeeds only if the dependent event has also succeeded.\n\n    The goal is to compute the overall probability that the entire sequence of events will succeed in a given day.\n\n    Examples:\n    - Input: [(1, []), (2, [(1, 0.9)]), (3, [(2, 0.8)])]\n      Explanation: Event 1 has no dependencies (always succeeds). Event 2 succeeds with probability 0.9 if Event 1 succeeds. Event 3 succeeds with probability 0.8 if Event 2 succeeds.\n      Calculation: Success probability = 1 * 0.9 * 0.8 = 0.72\n\n    Note:\n    - The dependency graph defined by the list of events will not contain cycles, but your implementation should handle cycles appropriately by returning a probability of zero for such cases.\n    \"\"\"", "canonical_solution": "    def event_success_probability(event, events_dict, cache):\n        if event in cache:\n            return cache[event]\n        dependencies = events_dict[event]\n        if not dependencies:\n            cache[event] = 1.0\n            return 1.0\n        prob = 1.0\n        for parent, p in dependencies:\n            parent_prob = event_success_probability(parent, events_dict, cache)\n            prob *= parent_prob * p\n            if parent_prob == 0.0:  # Handle cycles by detecting zero probability\n                return 0.0 \n        cache[event] = prob\n        return prob\n\n    events_dict = {event: dependencies for event, dependencies in events}\n    cache = {}\n    result = 1.0\n    for event in events_dict:\n        event_prob = event_success_probability(event, events_dict, cache)\n        result *= event_prob\n    return result", "test": "def check(candidate):\n    assert abs(candidate([(1, []), (2, [(1, 0.9)]), (3, [(2, 0.8)])]) - 0.72) < 0.0001\n    assert abs(candidate([(1, [])]) - 1.0) < 0.0001\n    assert abs(candidate([(1, [(2, 0.5)]), (2, [(1, 0.9)])]) - 0.0) < 0.0001  # Handling of cycle\n    assert abs(candidate([(1, []), (2, [(1, 0.95)]), (3, [(2, 0.85)]), (4, [(3, 0.9)])]) - 0.72675) < 0.0001\n    assert abs(candidate([(1, [])]) - 1.0) < 0.0001", "entry_point": "enchanted_instrument_success_probability", "extra_info": {"cover_story_words": ["enchanted instrument", "farm"], "topics": ["Probabilities", "Dependency chain"], "field": "Probabilistic dependencies", "cleaned_prompt": "Given a list of events with their dependencies and respective conditional probabilities, calculate the overall probability that a chain of events in a day all succeed. An event is defined by its identifier and each dependent event has a conditional success probability. The input list of tuples has the format (event identifier, [(dependent event identifier, conditional probability), ...]). Calculate the success probability of the chain of events for a day. The solution should correctly handle cases where cycles in dependencies would otherwise result in an incorrect computation.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 20)", "4, Unclear specification on events with no dependencies: The problem statement does not explicitly specify the probability of events that have no dependencies. Though an example infers that such events always succeed (probability = 1.0), this assumption should be clearly stated as a rule in the prompt for absolute clarity to avoid ambiguity."]}}
{"task_id": "hard/9", "prompt": "def max_loot_time_clock(events, cooldown):\n    \"\"\"\n    In a wild-west themed world with a time-bending clock, a series of events to rob valuable items appear over a time continuum. Each event is described as a tuple (start_time, end_time, loot_value) representing the start and end timing of the event and the value of the loot that can be extracted by attending the event in its entirety.\n\n    However, there's a cooldown mechanism with the time-bending clock such that after attending one event, you can't attend another event that starts within 'cooldown' time after the end of the previous event.\n\n    Write a function that takes a list of events and an integer 'cooldown' and returns the maximum total value of loot that can be collected by optimally choosing events considering the constraints imposed by cooldown. When multiple events can be chosen with the same start time or close end times within the cooldown period, preference should be given to the event with the higher loot value.\n\n    For example:\n    - If events = [(1, 3, 50), (4, 6, 10), (2, 5, 80)] and cooldown = 1, the maximum loot is 130 (attend events indexed at 0 and 1).\n    - If events = [(2, 5, 40), (1, 4, 60), (6, 7, 20), (5, 9, 100)] and cooldown = 1, the maximum sensible choice for loot optimization is the event indexed at 3 for a loot of 100, given earlier overlapping and cooldown issues.\n\n    Note:\n    - No two events can overlap in time.\n    - If there's no valid way to attend any event (due to overlapping times or cooldown constraints), return 0.\n    \"\"\"\n", "canonical_solution": "    events.sort(key=lambda x: (x[1], -x[2]))\n    n = len(events)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_event = events[i - 1]\n        # Find the latest non-overlapping event\n        j = i - 1\n        while j > 0 and events[j - 1][1] + cooldown > current_event[0]:\n            j -= 1\n        dp[i] = max(dp[i - 1], dp[j] + current_event[2])\n    return dp[n]", "test": "def check(candidate):\n    assert candidate([(1, 3, 50), (4, 6, 10), (2, 5, 80)], 1) == 130\n    assert candidate([(2, 5, 40), (1, 4, 60), (6, 7, 20), (5, 9, 100)], 1) == 100\n    assert candidate([(1, 2, 10), (3, 5, 20), (2, 6, 70)], 2) == 70\n    assert candidate([(3, 6, 85), (1, 4, 30), (7, 10, 150)], 1) == 235\n    assert candidate([], 2) == 0\n    assert candidate([(0, 1, 20), (1, 2, 40), (0, 3, 100)], 5) == 100", "entry_point": "max_loot_time_clock", "extra_info": {"cover_story_words": ["time-bending clock", "wild west"], "topics": ["Dynamic Programming", "Interval Scheduling"], "field": "", "cleaned_prompt": "Write a function that takes a list of events (each represented by a tuple containing start time, end time, and loot value) and an integer 'cooldown'. Calculate the maximum total loot that can be collected without overlapping events and considering the cooldown. Events can be sorted and chosen based on their end time and loot value to optimize the loot collection.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Clarification Required in Problem Statement: The problem statement ambiguously states that \"No two events can overlap in time\" but also provides an example where events do overlap. This inconsistency can confuse potential problem solvers as to which events are considered valid between examples; clarification or modification is needed to define allowed event overlaps or adjust examples to avoid them. The given examples seem to consider overlapping times based on the end time and cooldown restrictions, but this contradicts the stated rule of non-overlapping events.", "4, Inadequate Problem Specification on Event Sorting: The problem vaguely describes the preference for higher loot value events without explicitly dictating a sort priority between overlapping events. Since the canonical solution considers events sorted by end time first then by the negative of the loot value, this should be comprehensively outlined in the problem statement to prevent misunderstanding or incorrect implementations.", "4, Example Misalignment with Canonical Solution: The examples provided, particularly implications on event overlaps and cooldown effects, do not fully align with the logic in the canonical solution. There is room for discrepancies when the solution logic is applied to edge cases or scenarios not explicitly covered in examples. More detailed or additional representative examples could avoid potential misunderstandings or incorrect assumptions by problem solvers."]}}
{"task_id": "hard/7", "prompt": "def optimal_gem_distribution(gemstones, reviewers):\n    \"\"\"\n    Imagine you are a consultant for a high-end gemstone mine, which has recently discovered treasures requiring unique expertise to evaluate. Each gemstone is unique in its value and rarity. Besides, there is a list of expert reviewers, each with a probability of approving a gemstone based on its characteristics.\n\n    You need to distribute the gemstones among the reviewers such that the probability of getting all gemstones approved is maximized, even if the numbers of gemstones and reviewers are different.\n\n    The gemstones are represented as a list of tuples (value, rarity) where value is an integer and rarity is a float.\n    The reviewers are represented as a list of functions, where each function takes a gemstone tuple and returns the probability (0 <= p <= 1) of that reviewer approving the gemstone.\n\n    The function should return a distribution list where each element is a tuple (reviewer_index, gemstone_index) indicating that the gemstone at gemstone_index is assigned to the reviewer at reviewer_index to maximize the overall probability of approval. If there are more gemstones than reviewers, each reviewer can review more than one gemstone; if there are more reviewers than gemstones, some reviewers may not receive a gemstone.\n\n    Example:\n    gemstones = [(10, 0.2), (20, 0.5), (30, 0.3)]\n    reviewers = [\n        lambda g: 0.9 if g[1] < 0.3 else 0.2,\n        lambda g: 0.7 if g[0] > 15 else 0.1\n    ]\n    The output should be [(0, 0), (1, 1), (0, 2)] as it maximizes the overall probability of approval.\n\n    Note:\n    - Be sure to handle the cases where the number of gemstones and reviewers are different.\n    \"\"\"", "canonical_solution": "    from itertools import permutations\n    import numpy as np\n    def total_probability(distribution):\n        product = 1\n        for reviewer_idx, gemstone_idx in distribution:\n            product *= reviewers[reviewer_idx](gemstones[gemstone_idx])\n        return product\n\n    max_probability = 0\n    optimal_distribution = []\n    for perm in permutations(range(len(reviewers)), len(gemstones)):\n        distribution = list(zip(range(len(reviewers)), np.random.permutation(perm)))\n        current_probability = total_probability(distribution)\n        if current_probability > max_probability:\n            max_probability = current_probability\n            optimal_distribution = distribution\n\n    return optimal_distribution", "test": "def check(candidate):\n    gemstones1 = [(10, 0.2), (20, 0.5), (30, 0.3)]\n    reviewers1 = [\n        lambda g: 0.9 if g[1] < 0.3 else 0.2,\n        lambda g: 0.7 if g[0] > 15 else 0.1\n    ]\n    assert set(candidate(gemstones1, reviewers1)) == set([(0, 0), (1, 1), (0, 2)])\n\n    gemstones2 = [(5, 0.5), (15, 0.1), (25, 0.4), (35, 0.2)]\n    reviewers2 = [\n        lambda g: 0.8 if g[1] < 0.25 else 0.3,\n        lambda g: 0.6 if g[0] < 20 else 0.2\n    ]\n    assert set(candidate(gemstones2, reviewers2)) == set([(0, 1), (0, 3), (1, 0), (1, 2)])\n\n    gemstones3 = [(12, 0.15), (22, 0.55)]\n    reviewers3 = [\n        lambda g: 0.85 if g[1] < 0.5 else 0.15,\n        lambda g: 0.65 if g[0] > 20 else 0.05\n    ]\n    assert set(candidate(gemstones3, reviewers3)) == set([(0, 0), (1, 1)])\n\n    gemstones4 = [(10, 0.1)]\n    reviewers4 = [lambda g: 0.8 if g[1] < 0.2 else 0.1, lambda g: 0.9 if g[1] < 0.2 else 0.2]\n    assert set(candidate(gemstones4, reviewers4)) == set([(1, 0)])\n\n    gemstones5 = [(10, 0.1), (15, 0.2), (20, 0.3)]\n    reviewers5 = [lambda g: 0.9 if g[1] < 0.3 else 0.1]\n    assert set(candidate(gemstones5, reviewers5)) == set([(0, 0), (0, 1), (0, 2)])", "entry_point": "optimal_gem_distribution", "extra_info": {"cover_story_words": ["gemstone mine", "restaurant"], "topics": ["Probability and Statistics", "Jarvis March"], "field": "", "cleaned_prompt": "Write a function that takes a list of gemstone tuples (value, rarity) and a list of reviewer functions. Each reviewer function takes a gemstone tuple and returns the probability of approving the gemstone. The function should return a list of tuples (reviewer_index, gemstone_index) to maximize the probability of all gemstones getting approved. - Gemstones are represented as (value, rarity) tuples. - Reviewers are functions returning probabilities based on gemstone characteristics. - Handle different counts of gemstones and reviewers. Each reviewer can handle multiple gemstones or may not receive any, depending on the counts.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 22)", "4, Ambiguity in Problem Statement: The problem statement is unclear about the expected behaviour or method of 'maximizing the overall probability of approval' when the distribution possibilities of gemstones to reviewers can significantly vary. This results in an exponential number of combinations to evaluate, which may not be tractable for a larger set of gemstones and reviewers.", "5, Unsolvable Complexity: No feasible solution is provided to handle combinations efficiently when the number of gemstones and reviewers differ. The combinations\u2019 factor increases non-linearly, making brute-force or permutation-based approaches impractical for larger inputs. The solution attempts to utilize permutations, but it falls short of efficiently handling complex cases and large inputs.", "5, Inequity in Assignment Distribution Strategy: The problem does not specify how to ensure fairness or a technically sound distribution when there are more reviewers than gemstones or vice versa. Without such guidance or constraints, solutions might be overly simplified or unfairly distribute workloads, leading to suboptimal or misunderstood implementation efforts."]}}
