{"task_id": "hard/4", "prompt": "def haunting_forecast(machine_readings):\n    \"\"\"\n    In a ghost town, an intricate weather machine records wind patterns in the form of a linked list where each node represents a distinct wind condition denoted by a character. Unfortunately, the readings are in chronological order from oldest to newest. For optimal analysis and forecasting, these readings should be presented from newest to oldest.\n\n    This task requires you to reverse the given singly linked list that represents the machine's readings, thereby helping in generating better forecasts with the most recent data first.\n\n    Example usage:\n    Input: A -> B -> C -> D -> None   (Linked list form: Head=A, Tail=None)\n    Output: D -> C -> B -> A -> None  (Reversed Linked List)\n\n    Note: In a singly linked list, each node only has a reference to the next node and not to the previous one.\n    \"\"\"", "canonical_solution": "    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n\n    def haunting_forecast(head):\n        prev = None\n        current = head\n        while current:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        return prev", "test": "def check(candidate):\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n\n    def list_to_str(head):\n        result = []\n        while head:\n            result.append(head.val)\n            head = head.next\n        return ' -> '.join(result) + ' -> None'\n\n    node1 = ListNode('A', ListNode('B', ListNode('C', ListNode('D'))))\n    assert list_to_str(candidate(node1)) == 'D -> C -> B -> A -> None'\n\n    node2 = ListNode('1')\n    assert list_to_str(candidate(node2)) == '1 -> None'\n\n    node3 = None\n    assert candidate(node3) == None\n\n    node4 = ListNode('X', ListNode('Y'))\n    assert list_to_str(candidate(node4)) == 'Y -> X -> None'\n\n    node5 = ListNode('P', ListNode('Q', ListNode('R', ListNode('S', ListNode('T')))))\n    assert list_to_str(candidate(node5)) == 'T -> S -> R -> Q -> P -> None'", "entry_point": "haunting_forecast", "extra_info": {"cover_story_words": ["weather machine", "ghost town"], "topics": ["Reverse Linked List"], "field": "", "cleaned_prompt": "Given a singly linked list representing machine recorded wind conditions from oldest to newest, return a reversed linked list with the readings from newest to oldest.\n\nExample:\nInput: A -> B -> C -> D -> None\nOutput: D -> C -> B -> A -> None", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 12)", "4, Lack_of_interactive_elements: The problem lacks interactive or more complex elements that could make it more engaging for a coding competition. It revolves only around a fundamental operation on a data structure, which might not be sufficiently challenging for a competitive environment, especially labeled under a \"hard\" difficulty setting.", "5, Mismatched_difficulty_label: The task of reversing a linked list is generally considered a basic problem in data structures and algorithms. Labeling this problem as \"hard\" might mislead participants about the expected complexity or cause confusion regarding the problem's actual difficulty level."]}}
{"task_id": "hard/8", "prompt": "def sentient_rock_path_artifacts(rock_relations, artifact_connections):\n    \"\"\"\n    In a fantastical world, sentient rocks guard the pathways between various artifacts of immense power. \n    Each rock has a connection to one or multiple artifacts and these connections are represented as pairs in the form of (rock, artifact).\n\n    Your job is to find the maximum number of paths from rocks to artifacts such that each path connects a rock and an artifact directly and no rock or artifact is used in more than one path. Additionally, given links between artifacts can modify the path length calculations by introducing indirect paths that should be counted if they provide a shorter route.\n\n    Paths should minimize the 'depth' or the number of hops between rocks and their connected artifacts considering direct rock-to-artifact connections and any applicable indirect connections through other artifacts as defined in artifact_connections.\n\n    Parameters:\n    - rock_relations (List[Tuple[str, str]]): A list of tuples representing direct connections between rocks and artifacts.\n    - artifact_connections (List[Tuple[str, str]]): A list of tuples representing the potential indirect pathways for calculating shortest paths between artifacts.\n\n    Examples:\n    - If rock_relations = [('R1', 'A1'), ('R2', 'A1'), ('R3', 'A2'), ('R4', 'A1'), ('R4', 'A3')] and artifact_connections = [('A1', 'A2'), ('A2', 'A3')] then the function should consider the shortest path implications of these connections and return a result accordingly.\n\n    Return:\n    - An integer representing the maximum number of non-overlapping, shortest-path connections from rocks to artifacts.\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    def construct_graphs(rock_relations, artifact_connections):\n        # Implementation constructs a graph using both rock_relations and artifact_connections\n        # Details provided for adding edges and incorporating shortest path implications\n    def hopcroft_karp(graph):\n        # Customized Hopcroft-Karp to account for shortest paths derived from artifact connections\n        # Actual implementation may vary\n    return hopcroft_karp(construct_graphs(rock_relations, artifact_connections))\n", "test": "def check(candidate):\n    assert candidate([('R1', 'A1'), ('R1', 'A2'), ('R2', 'A2')], [('A1', 'A2')]) == 2\n    assert candidate([('R1', 'A1'), ('R2', 'A1'), ('R3', 'A2')], []) == 2\n    assert candidate([], []) == 0\n    assert candidate([('R1', 'A1')], []) == 1\n    assert candidate([('R1', 'A1'), ('R2', 'A1'), ('R2', 'A2'), ('R3', 'A2')], [('A1', 'A3'), ('A2', 'A3')]) == 3", "entry_point": "sentient_rock_path_artifacts", "extra_info": {"cover_story_words": ["treasure", "sentient rocks"], "topics": ["Graph Theory", "Shortest Path", "Bipartite Matching", "Hopcroft-Karp Algorithm"], "field": "Computer Science", "cleaned_prompt": "Implement a function that computes the maximum number of non-overlapping shortest paths between rocks and artifacts, considering direct connections and additional paths provided by connections between artifacts. The solution should utilize graph theory methods to deduce shortest paths and employ the Hopcroft-Karp algorithm for finding maximum matching in view of minimized path depths.", "warnings": ["Solution failed correctness check. reason: failed: expected an indented block (<string>, line 24)", "4, Unclear Problem Definition: The problem description states that paths should minimize the 'depth' or number of hops yet the primary goal explained afterwards is to maximize the number of non-overlapping paths. This leads to confusion about whether the complexity of creating minimal-depth paths will interfere or contradict with maximizing the number of distinct paths. The task doesn't clarify how these two objectives should be balanced if they come into conflict.", "4, Performance Concerns: The problem seems to require checking multiple conditions and potentially recalculating optimal paths when considering indirect paths through artifact_connections while maximizing distinct paths. For larger datasets, ensuring performance efficiency could be complex and isn't addressed in the problem constraints or any provided pseudocode."]}}
{"task_id": "hard/7", "prompt": "def next_greater_flower(heights):\n    \"\"\"\n    In the enchanted garden of a magical amusement park, various flowers are arranged in a certain order. Each flower has a height represented by a list of integers. The garden has been enchanted such that each flower can communicate with its immediate next flower that is strictly taller than it. Your task is to write a function that determines for each flower in the garden, the height of the next strictly taller flower. If no such flower exists, the enchanted garden communicates a '0' at that position.\n\n    The function should return a list of integers where each integer corresponds to the height of the next strictly taller flower for each given flower in the input list, or '0' if there is no taller flower. The output strictly respects the order of appearance in the list.\n\n    Examples:\n    If heights = [1, 3, 2, 5, 3, 4, 1], then the output should be [3, 5, 5, 0, 4, 0, 0].\n    For heights = [5, 4, 3, 2, 1], the output should be [0, 0, 0, 0, 0] since no flower is taller than any other following it in the order.\n    \"\"\"\n", "canonical_solution": "    stack = []\n    result = [0] * len(heights)\n    for i in range(len(heights)):\n        while stack and heights[stack[-1]] < heights[i]:\n            result[stack.pop()] = heights[i]\n        stack.append(i)\n    return result", "test": "def check(candidate):\n    assert candidate([1, 3, 2, 5, 3, 4, 1]) == [3, 5, 5, 0, 4, 0, 0]\n    assert candidate([5, 4, 3, 2, 1]) == [0, 0, 0, 0, 0]\n    assert candidate([]) == []\n    assert candidate([7]) == [0]\n    assert candidate([3, 3, 3, 3]) == [0, 0, 0, 0]\n    assert candidate([10, 20, 30, 40, 50]) == [20, 30, 40, 50, 0]\n    assert candidate([100, 90, 80, 70, 60]) == [0, 0, 0, 0, 0]", "entry_point": "next_greater_flower", "extra_info": {"cover_story_words": ["enchanted garden", "amusement park"], "topics": ["Monotonic Stack", "Interactive"], "field": "", "cleaned_prompt": "Write a function that returns a list of integers where each integer represents the height of the next strictly taller flower for each flower in the input list, or '0' if no taller flower is present. Use 'Monotonic Stack' for optimal performance. Clarify that outputs are strictly derived from order in the list. E.g., [1, 3, 2, 5, 3, 4, 1] yields [3, 5, 5, 0, 4, 0, 0].", "warnings": ["5, Incomplete Problem Description: The problem statement does not specify the allowable range or type for the elements of the heights list. This is crucial for handling edge cases and ensuring robust candidate function implementation.", "4, Missing Constraints: There's a lack of information regarding possible limits on the length of the heights list. Constraints are essential for understanding expected computational complexity and memory usage, guiding optimal algorithm implementations like Monotonic Stack mentioned in the topics.", "5, Ambiguity in Problem Scope: The use of \"enchanted garden\" and \"magical amusement park\" possibly suggests an interactive or real-time component, yet the problem's solutions and tests provided do not account for or make use of any interactive features. It possibly leads to confusion about the problem's requirements."]}}
{"task_id": "hard/1", "prompt": "def interstellar_shipping_log(signals):\n    \"\"\"\n    In the future, a group of monks from the mystic monastery have developed a new way to communicate between planets using a special sequence of signals. These sequences consist of an increasing sequence of numeric codes followed by its exact reversal to form a digital palindrome-like sequence.\n\n    Your task is to write a function that takes a list of integers (signals) representing these signal sequences and determine the maximum length of a contiguous subsequence that appears to form a valid palindrome-like sequence. A valid sequence strictly increases to a peak value and then decreases in symmetry to the sequence's start.\n\n    For example, if the input is [2, 3, 4, 4, 3, 2], the output should be 6 since the entire list forms a palindrome-like sequence. Another example with [1, 2, 3, 7, 3, 2, 1], the output should be 7. If the sequence contains no such structure, return 0.\n\n    Note:\n    - The input list may contain negative numbers.\n    - Input size can go above 1000 elements.\n    \"\"\"\n", "canonical_solution": "    def is_valid_peak_sequence(sequence):\n        n = len(sequence)\n        mid = n // 2\n        if n % 2 == 0 and any(sequence[i] < sequence[i + 1] for i in range(mid - 1)):\n            return False\n        for i in range(mid):\n            if sequence[i] != sequence[n - 1 - i]:\n                return False\n        return True\n\n    def interstellar_shipping_log(signals):\n        max_len = 0\n        n = len(signals)\n        for start in range(n):\n            for end in range(start + 1, n + 1):\n                subseq = signals[start:end]\n                if is_valid_peak_sequence(subseq):\n                    max_len = max(max_len, len(subseq))\n        return max_len\n", "test": "def check(candidate):\n    assert candidate([2, 3, 4, 4, 3, 2]) == 6\n    assert candidate([1, 2, 3, 7, 3, 2, 1]) == 7\n    assert candidate([2, 2, 3, 3, 2, 2]) == 0\n    assert candidate([1, 2, 3, 2, 1]) == 5\n    assert candidate([1, 2, 3]) == 0\n    assert candidate([45, 46, 47, 46, 45]) == 5\n    assert candidate([]) == 0\n    assert candidate([-1, -2, -1, 0, -1, -2, -1]) == 7", "entry_point": "interstellar_shipping_log", "extra_info": {"cover_story_words": ["mystic monastery", "spaceship"], "topics": ["Jarvis March", "Prefix Sum"], "field": "", "cleaned_prompt": "Write a function to determine the maximum length of a contiguous subsequence in a list (of integers) that appears to form a valid palindrome-like sequence. The sequence should strictly increase to a midpoint and then replicate in reverse. Example: for [2, 3, 4, 4, 3, 2], output should be 6.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Incorrect example explanation: The explanation given for the sequence [2, 3, 4, 4, 3, 2] being a valid palindrome-like sequence seems contradictory as per prompt rules, which require a strict increase followed by a strict decrease. The presence of two '4's violates the strict increase rule.", "4, Unclear example validity: The example [1, 2, 3, 7, 3, 2, 1] is unclear regarding whether the peak value can be part of the non-strictly increasing sequence, as the sequence increases from 3 to 7 then decreases immediately, which doesn't follow a strictly increasing pattern provided in the prompt."]}}
{"task_id": "hard/5", "prompt": "def cosmic_game_planner(arrivals, durations):\n    \"\"\"\n    Imagine a scenario at the Cosmic Carnival amusement park where each guest has a specific arrival time and a predetermined duration of stay. The park's planner needs to prepare for a contest that is affected by the maximum number of guests present at any given time.\n\n    Write a function that takes two lists:\n    - `arrivals`: a list of integers where each integer represents the time a guest arrives.\n    - `durations`: a list of integers where each integer represents the duration (in the same time units) that each guest will stay after arriving.\n\n    The function should compute the maximum number of guests present in the park at any given point in time.\n\n    Example:\n    arrivals = [1, 2, 3]\n    durations = [5, 6, 7]\n    The function should return 3, as there are 3 guests overlapping from time unit 3 to 4 inclusively.\n\n    Note:\n    - Both lists have the same length, and the arrival times are sorted in ascending order.\n    - Each value in 'arrivals' and 'durations' is a strictly positive integer.\n    \"\"\"", "canonical_solution": "def cosmic_game_planner(arrivals, durations):\n    events = []\n    for arrival, duration in zip(arrivals, durations):\n        events.append((arrival, 'arrive'))\n        events.append((arrival + duration, 'depart'))\n    events.sort(key=lambda x: (x[0], x[1] == 'depart'))\n    max_guests = 0\n    current_guests = 0\n    for event in events:\n        if event[1] == 'arrive':\n            current_guests += 1\n        elif event[1] == 'depart':\n            current_guests -= 1\n        max_guests = max(max_guests, current_guests)\n    return max_guests", "test": "def check(candidate):\n    assert candidate([1, 3, 5], [5, 2, 6]) == 3\n    assert candidate([1, 2, 3], [1, 2, 3]) == 3\n    assert candidate([1, 1, 1], [1, 1, 1]) == 3\n    assert candidate([1, 2, 3], [5, 6, 7]) == 3\n    assert candidate([1, 2, 4, 6], [10, 5, 2, 4]) == 4", "entry_point": "cosmic_game_planner", "extra_info": {"cover_story_words": ["amusement park", "cosmic carnival"], "topics": ["Number Theory", "Line Sweep"], "field": "", "cleaned_prompt": "Write a function that calculates the maximum count of guests in the park at any given moment, given their arrival times and stay durations.\n\nExample usage:\narrivals = [1, 2, 3]\ndurations = [5, 6, 7]\nExpected output: 3", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 19)", "4, Duration Calculation Error: The problem statement and canonical solution have an issue with how guest departures are calculated. In the given solution, a guest who arrives at time 't' and has a duration 'd' is considered to depart at time 't + d'. This implies a guest with a duration of 1 unit would leave at the start of the next time unit, potentially being counted as present for zero time units if the check is not inclusive. The correct logic should either adjust departure to 't + d - 1' for inclusive counting or make it clear that 't + d' is exclusive.", "4, Ambiguous Overlap Count: The problem's example and the description suggest that guests staying from time unit 't' to 't + d' might be overlapped in calculations, like from time 3 to 4 inclusively for the provided example. However, the departure event handling in the canonical solution does not clarify if the inclusive or exclusive method is being used, which might lead to incorrect maximum guest calculations in boundary cases."]}}
{"task_id": "hard/10", "prompt": "def escape_zoo(map_layout):\n    \"\"\"\n    Imagine you are in a virtual zoo simulation where you are surrounded by cages connected with each other via paths represented as a grid, in a string format. There are certain animals that cast sneaky shadows ('S') on some paths that you should avoid. You are initially at the entrance of the zoo (upper left corner of the grid) and need to find your way to the exit (lower right corner of the grid) while avoiding these paths.\n\n    The map_layout is represented as a list of strings, where each string corresponds to a row in the grid:\n    - '#' represents a wall which you cannot pass.\n    - 'S' represents a sneaky shadow path to be avoided.\n    - ' ' (space) represents a free path that you can walk through.\n    - The entrance is always located at the top-left corner (map_layout[0][0]).\n    - The exit is always located at the bottom-right corner (map_layout[-1][-1]).\n\n    Your task is to determine if there is a viable path from the entrance to the exit without traversing any 'S' paths, using a Breadth-First Search (BFS) approach. Additionally, the function should correctly handle scenarios where the entrance or the exit are initially blocked (either by a wall '#' or a shadow 'S').\n\n    For example:\n    escape_zoo([\n        ' #  ',\n        '  S# ',\n        '### ']) returns False because all paths from entrance to exit are blocked.\n\n    escape_zoo([\n        '    ',\n        ' SS# ',\n        '### ']) returns True, as there is an accessible path avoiding all shadows and walls.\n\n    Note:\n    - Ensure to handle the edge cases where the entrance or exit might be blocked.\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n\n    def escape_zoo(map_layout):\n        def is_within_bounds(x, y):\n            return 0 <= x < len(map_layout) and 0 <= y < len(map_layout[0])\n\n        def is_walkable(x, y):\n            return map_layout[x][y] == ' '\n\n        def bfs(start):\n            if not is_walkable(start[0], start[1]):\n                return False\n            queue = deque([start])\n            visited = set([start])\n            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n            while queue:\n                x, y = queue.popleft()\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if (nx, ny) not in visited and is_within_bounds(nx, ny) and is_walkable(nx, ny):\n                        if (nx, ny) == (len(map_layout) - 1, len(map_layout[0]) - 1):\n                            return True\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n            return False\n\n        return bfs((0, 0))\n", "test": "def check(candidate):\n    assert candidate(['  #', '  S#', '###']) == False\n    assert candidate(['    ', ' SS#', '### ']) == True\n    assert candidate(['##  ', ' # S', '   S']) == False\n    assert candidate([' #', '  ']) == True\n    assert candidate(['  S', 'S##', ' ##']) == False\n", "entry_point": "escape_zoo", "extra_info": {"cover_story_words": ["zoo", "sneaky shadows"], "topics": ["Breadth-First Search", "String"], "field": "", "cleaned_prompt": "Write a function to find a path from the entrance to the exit in a zoo represented as a grid layout string avoiding paths marked by 'S' using Breadth-First Search (BFS). '#': wall, 'S': shadow path, ' ': free path. Entrance at top-left, exit at bottom-right. Return True if a path exists, otherwise False, and handle cases where starting or ending points are blocked.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, Inconsistent Output Type: The canonical solution and problem statement do not make it clear if the return type should specifically be a Boolean (True/False). This ambiguity can lead to varied interpretations and implementations where any falsy or truthy values might mistakenly be considered valid outputs."]}}
{"task_id": "hard/9", "prompt": "def enchanted_forest_paths(costs, operations):\n    \"\"\"\n    In an enchanted forest, you have a crystal ball and an enchanted book that reveal to you the costs to repair paths between trees and how you can modify these costs. This enchanted setting requires you to update and calculate the minimal cost needed to connect all trees through paths using a Minimum Spanning Tree (MST) calculation after modifying the paths' costs based on given operations.\n\n    Inputs:\n    - costs: A list of tuples (i, j, cost) representing the initial cost to repair the path between trees i and j.\n    - operations: A list of tuples (i, j, operation_type, value) where operation_type can be 'set' (replace cost) or 'add' (modify cost by adding value).\n\n    Task:\n    - For each operation, if it is relevant (i.e., it alters a path that exists in the initial costs), recalculate and output the new minimum MST cost after applying the operation. If a path does not exist in the initial costs, the operation is ignored.\n    - The changes to the path costs should be cumulative through the operations list.\n    - Return the MST cost after each operation. If any operation leads to a forest where not all trees can be connected by paths, return 'impossible' for that case.\n\n    Example:\n    - Input: costs = [(0, 1, 10), (1, 2, 15), (0, 2, 20)], operations = [(1, 2, 'add', -5), (0, 1, 'set', 5)]\n    - Output: [10, 10]\n\n    Note:\n    Always ignore irrelevant operations (i.e., those involving trees not directly connected in the initial costs list).\n    \"\"\"\n    return []", "canonical_solution": "    def find(parent, i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent, parent[i])\n        return parent[i]\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    original = { (i, j): cost for i, j, cost in costs }\n    results = []\n    for (i, j, op_type, value) in operations:\n        if (i, j) in original or (j, i) in original:\n            if op_type == 'add':\n                original[(i, j)] += value\n            elif op_type == 'set':\n                original[(i, j)] = value\n            elif op_type == 'set' and not (i, j) in original and (j, i) in original:\n                original[(j, i)] = value\n\n        parent = [i for i in range(len(set(original.keys())))]\n        rank = [0] * len(parent)\n        edges = sorted(original.items(), key=lambda x: x[1])\n        result = 0\n        num_edges = 0\n        for (i, j), cost in edges:\n            if find(parent, i) != find(parent, j):\n                union(parent, rank, i, j)\n                result += cost\n                num_edges += 1\n                if num_edges == len(parent) - 1:\n                    break\n\n        if num_edges == len(parent) - 1:\n            results.append(result)\n        else:\n            results.append('impossible')\n    return results", "test": "def check(candidate):\n    assert candidate([(0, 1, 10), (1, 2, 15), (0, 2, 20)], [(1, 2, 'add', -5), (0, 1, 'set', 5)]) == [10, 10]\n    assert candidate([(0, 1, 3), (1, 2, 4), (2, 3, 2), (3, 0, 8)], [(1, 2, 'set', 1)]) == [8]\n    assert candidate([(0, 1, 10)], [(0, 1, 'add', -5), (1, 0, 'set', 1)]) == [5, 1]\n    assert candidate([(0, 1, 1), (1, 2, 2)], [(2, 3, 'set', 5)]) == [3]\n    assert candidate([], []) == []", "entry_point": "enchanted_forest_paths", "extra_info": {"cover_story_words": ["crystal ball", "enchanted book"], "topics": ["Simulation", "Minimum Spanning Tree"], "field": "", "cleaned_prompt": "Define a function `enchanted_forest_paths(costs, operations)` that uses operations to adjust the costs of paths in an enchanted forest and recalculates the minimum spanning tree (MST) after each adjustment. Return the MST cost after each operation, or 'impossible' if not all trees can be connected.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 21)", "4, Ambiguity in Operation Definitions: The problem statement does not clearly specify how operations should handle cases where a path might be represented both as (i, j) and (j, i) due to the undirected nature of the paths. It's ambiguous whether operations like 'set' or 'add' should uniformly treat (i, j) and (j, i) as the same path. This can lead to inconsistent operation application if the underlying data structure or algorithm treats these paths differently based on the tuple order.", "4, Lack of Specification for Node Indexing: There is no definition of how trees (nodes) are indexed, if index starts from 0 or 1, or the valid range of indices. This lack of specification might lead to inconsistencies, especially when different contributors assume different starting indices for trees."]}}
{"task_id": "hard/2", "prompt": "def enchanted_invisibility_cloak(serial_codes):\n    \"\"\"\n    In an enchanted marketplace, invisibility cloaks are encoded with magical serial codes. Each serial code is a string made up of lowercase English letters. The enchantment's power is determined by the ability to partition the serial code into the smallest possible number of palindromic substrings.\n\n    A palindromic substring is a sequence of characters which reads the same backward as forward.\n\n    Write a function `enchanted_invisibility_cloak` that takes a list of serial codes and returns a list where each element corresponds to the minimal number of palindromic substrings the respective serial code can be partitioned into.\n\n    Example:\n    If the input is ['abc', 'aabb', 'racecar', 'madam'], the output should be [3, 2, 1, 1].\n    - 'abc' can be partitioned as ['a', 'b', 'c'] (3 parts)\n    - 'aabb' can be parted as ['aa', 'bb'] (2 parts)\n    - 'racecar' is already a palindrome (1 part)\n    - 'madam' is already a palindrome (1 part)\n\n    Notes:\n    - Assume all input strings are non-empty and consist only of lowercase English characters.\n    \"\"\"\n    # Implementation here", "canonical_solution": "def enchanted_invisibility_cloak(serial_codes):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def min_partitions(string):\n        n = len(string)\n        if is_palindrome(string):\n            return 1\n        # Create a DP array\n        dp = [0] * (n + 1)\n        # Base case\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            min_cut = float('inf')\n\n            for j in range(1, i + 1):\n                if is_palindrome(string[i-j:i]):\n                    min_cut = min(min_cut, dp[i-j] + 1)\n\n            dp[i] = min_cut\n\n        return dp[n]\n    return [min_partitions(code) for code in serial_codes]", "test": "def check(candidate):\n    assert candidate(['abc']) == [3]\n    assert candidate(['aabb', 'racecar']) == [2, 1]\n    assert candidate(['madam', 'noon', 'xyz']) == [1, 1, 3]\n    assert candidate(['level', 'civic', 'deified']) == [1, 1, 1]\n    assert candidate(['ab', 'aa', 'aba']) == [2, 1, 1]", "entry_point": "enchanted_invisibility_cloak", "extra_info": {"cover_story_words": ["invisibility cloak", "enchanted marketplace"], "topics": ["Palindrome Partitioning"], "field": "", "cleaned_prompt": "def enchanted_invisibility_cloak(serial_codes):\n    \"\"\"\n    Takes a list of serial codes and returns a list of the minimal number of palindromic substrings each code can be partitioned into.\n\n    A palindromic substring is a sequence of characters which reads the same backward as forward.\n\n    Examples:\n    - Input: ['abc'], Output: [3]\n    - Input: ['aabb', 'racecar'], Output: [2, 1]\n    - Input: ['madam', 'noon', 'xyz'], Output: [1, 1, 3]\n\n    Assume all strings only contain lowercase letters and are non-empty.\n    \"\"\"", "warnings": ["5, Ambiguity in Solution Example: The problem ambiguously describes the expected output format for the partition process, focusing mainly on the number of partitions required for palindromic substrings without explicit rules or guidelines on how substrings are chosen in serial codes with multiple valid partitions. This could lead to multiple valid outputs based on differing interpretations, affecting grading and validation systems."]}}
{"task_id": "hard/6", "prompt": "def factory_network_optimization(universes, wormholes, production_A, production_B):\n    \"\"\"\n    In an interdimensional factory network, you're tasked with optimizing the flow of resources between parallel universes using wormholes.\n    Each universe is considered a node in a graph, and each wormhole acts as a bidirectional edge with a specified capacity between two universe nodes.\n\n    You're given:\n    - universes: a list of universe names (strings). The order of elements in this list has no impact on the interpretation of wormhole connections.\n    - wormholes: a list of tuples (u1, u2, capacity) where each tuple represents a wormhole with a specified capacity between universe u1 and u2.\n    - production_A: the name of the universe where production starts (source).\n    - production_B: the name of the universe where production ends (sink).\n\n    Implement the Edmonds-Karp algorithm to calculate the maximum flow of resources from the source universe (production_A) to the sink universe (production_B).\n\n    Note:\n    - Each universe can only be listed once in the 'universes' list. Unlisted universes in wormhole connections are considered invalid input.\n    - No self-loop wormholes are allowed.\n    - Each pair of universes can have at most one direct bidirectional wormhole.\n    \"\"\"\n    pass", "canonical_solution": "    from collections import defaultdict, deque\n    def bfs_capacity(graph, source, sink, parent):\n        visited = set()\n        queue = deque([source])\n        visited.add(source)\n        while queue:\n            node = queue.popleft()\n            for adj in graph[node]:\n                if adj not in visited and graph[node][adj] > 0:\n                    queue.append(adj)\n                    visited.add(adj)\n                    parent[adj] = node\n                    if adj == sink:\n                        return True\n        return False\n\n    def edmonds_karp(graph, source, sink):\n        parent = {}\n        max_flow = 0\n        while bfs_capacity(graph, source, sink, parent):\n            path_flow = float('Inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, graph[parent[s]][s])\n                s = parent[s]\n            max_flow += path_flow\n            v = sink\n            while v != source:\n                u = parent[v]\n                graph[u][v] -= path_flow\n                graph[v][u] += path_flow\n                v = u\n        return max_flow\n\n    graph = defaultdict(lambda: defaultdict(int))\n    for u1, u2, cap in wormholes:\n        graph[u1][u2] += cap\n        graph[u2][u1] += cap  # since it's bidirectional\n\n    return edmonds_karp(graph, production_A, production_B)", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C'], [('A', 'B', 10), ('B', 'C', 5), ('A', 'C', 15)], 'A', 'C') == 20\n    assert candidate(['X', 'Y'], [('X', 'Y', 50)], 'X', 'Y') == 50\n    assert candidate(['U1', 'U2', 'U3'], [('U1', 'U2', 20), ('U2', 'U3', 20)], 'U1', 'U3') == 20\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'B', 10), ('B', 'C', 5), ('B', 'D', 15), ('D', 'C', 10)], 'A', 'C') == 15\n    assert candidate(['P', 'Q', 'R'], [('P', 'Q', 10), ('Q', 'R', 25)], 'P', 'R') == 10", "entry_point": "factory_network_optimization", "extra_info": {"cover_story_words": ["factory", "parallel universe"], "topics": ["Edmonds-Karp Algorithm"], "field": "", "cleaned_prompt": "Develop a function to compute maximum production flow across an interdimensional factory network modeled as a graph. Each universe represents a graph node, wormholes are bidirectional edges with capacities. You're provided with universe names, wormholes (u1, u2, capacity), and names of the start (source) and end (sink) universe for production. Implement the Edmonds-Karp algorithm correctly, ensuring proper graph representation with no influence from universe list order or assumptions about connection directionality between specific universe pairings.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 19)", "5, Unhandled Input Error Checking: The problem statement and function definition do not specify or implement any checks to validate that the universes mentioned in `production_A` and `production_B` are included in the `universes` list. This lack of validation might allow for situations where the source or sink universes are not part of the graph, leading to potential runtime errors or incorrect computations.", "4, Ambiguity in Error Handling: The prompt does not describe how to handle cases where the assumptions about the input data are violated, such as when a wormhole connects to an unknown universe not listed in the `universes` list. This leaves ambiguity around expected behavior under invalid input conditions, possibly leading to unpredictable function behavior."]}}
{"task_id": "hard/9", "prompt": "def magical_gallery(arr):\n    \"\"\"\n    In an enchanted art gallery, each piece of art has a value that changes daily. The curator of the gallery wants to know if there is any combination of three art pieces whose values sum up to zero. Your task is to write a function 'magical_gallery' that takes a list of integers representing today's values of art pieces and returns a list of unique triplets [a, b, c] from the list such that a + b + c = 0. Each triplet should be sorted in non-descending order, and the result list should also be sorted accordingly.\n\n    Example:\n    Input: [-1, 0, 1, 2, -1, -4]\n    Output: [[-1, -1, 2], [-1, 0, 1]]\n\n    Note:\n    - The input list can include duplicates which may lead to duplicate triplets if not handled.\n    - The result should not contain duplicate triplets.\n    - If no such triplet exists, return an empty list.\n    \"\"\"\n", "canonical_solution": "    arr.sort()\n    result = []\n    for i in range(len(arr)):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        left, right = i + 1, len(arr) - 1\n        while left < right:\n            sum = arr[i] + arr[left] + arr[right]\n            if sum == 0:\n                result.append([arr[i], arr[left], arr[right]])\n                while left < right and arr[left] == arr[left + 1]:\n                    left += 1\n                while left < right and arr[right] == arr[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif sum < 0:\n                left += 1\n            else:\n                right -= 1\n    return result", "test": "def check(candidate):\n    assert candidate([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]]\n    assert candidate([0, 0, 0, 0]) == [[0, 0, 0]]\n    assert candidate([3, -1, -7, 2, -4, 10]) == []\n    assert candidate([34, -21, -36, 22, 14, -49, 10, 25]) == [[-21, -36, 10, 25]]\n    assert candidate([1, 2, -3, 0, 5, 7, -2, -1]) == [[-3, 1, 2], [-2, -1, 3]]", "entry_point": "magical_gallery", "extra_info": {"cover_story_words": ["crystal ball", "art gallery"], "topics": ["3-Sum Problem"], "field": ["Reinforcement Learning"], "cleaned_prompt": "Given a list of integers representing the values for today's art pieces in a gallery, return all unique triplets where the sum of their values is zero and each triplet is sorted in non-descending order. If no such triplet exists, return an empty list. Each triplet should be unique, and the result list should be sorted.\n\nExample:\nInput: [-1, 0, 1, 2, -1, -4]\nOutput: [[-1, -1, 2], [-1, 0, 1]]", "warnings": ["Solution failed correctness check. reason: failed: ", "4, ambiguous_output_format: The output format specification and example do not clearly specify if the output triplets must always be sorted within each individual triplet as well as the entire list of triplets sorted among themselves. This ambiguity can lead to variations in valid outputs that could be considered incorrect if not consistently defined.", "5, logical_error_in_example: In the provided examples within the 'test' section, some of the outputs mentioned do not correctly sum up to zero, creating a misconception or misleading guidance for anyone developing or testing similar functions as the one described. This could challenge the validity and reliability of assuming the problem statement and example outputs are correct, leading to erroneous implementations."]}}
{"task_id": "hard/5", "prompt": "def sentinel_rock_cipher(message, rocks):\n    \"\"\"\n    Write a function that takes a string message and a list of integers rocks. Each integer in rocks represents a valued rock. The encryption of the message is determined by converting each character of the message into its ASCII value. Subsequently, only the rocks that are prime numbers (heavy rocks) are taken, and their product is used to modulate each ASCII value before converting them back to characters.\n\n    If there are no prime numbers in rocks (no heavy rocks), the function should return the original message.\n\n    This encryption ensures that the characters are shuffled in a way that their new values are the remainder when their ASCII values are divided by the product of the heavy rocks.\n\n    Examples:\n    - If rocks are [2, 3, 6, 7, 10], the heavy rocks are [2, 3, 7]. The product of these prime-valued rocks is 42. Each character's ASCII value in the message is modulated by 42 and then converted back to characters to form the encrypted message.\n    - If there are no heavy rocks, like in rocks = [4, 6, 8], the original message is returned.\n\n    Note: The function might return non-printable or special characters as part of the encrypted message due to the modulation operation.\n    \"\"\"\n", "entry_point": "sentinel_rock_cipher", "canonical_solution": "    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    modulus = 1\n    for rock in rocks:\n        if is_prime(rock):\n            modulus *= rock\n    if modulus == 1:\n        return message\n    else:\n        encrypted_message = ''.join(chr(ord(char) % modulus) for char in message)\n        return encrypted_message", "test": "def check(candidate):\n    assert candidate(\"Hello, world!\", [2, 3, 6, 7, 10]) == \"]6JU!I12JU@\"\n    assert candidate(\"Desert rocks\", [11, 13, 16]) == \"3M46C1*3CK2\"\n    assert candidate(\"No primes\", []) == \"No primes\"\n    assert candidate(\"abc\", [999]) == \"abc\"\n    assert candidate(\"12345\", [2, 5, 7, 11]) == \"N)*+*\"\n    assert candidate(\"Test with non-prime\", [4, 6, 8, 10]) == \"Test with non-prime\"", "extra_info": {"cover_story_words": ["desert", "sentient rocks"], "topics": ["Cryptography", "Number Theory"], "field": ["Cybersecurity"], "cleaned_prompt": "Write a function sentinel_rock_cipher(message, rocks) that takes a message (string) and rocks (list of integers). Encrypt the message by converting each character to its ASCII value and then modulating by the product of the prime-values in rocks, converting the result back to characters. If there are no prime values in rocks, return the original message.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, Overflow risk in product of heavy rocks: There is no safeguard in the function against overflow or extremely large values when calculating the product of prime-valued rocks ('heavy rocks'). This could lead to incorrect results or runtime errors due to integer overflow, especially for large inputs."]}}
{"task_id": "hard/1", "prompt": "def treasure_map_revision(secret_map, operations):\n    \"\"\"\n    Revise a given 'secret_map' to determine the hypothetical amount of rainwater that could be trapped between the map's segments after applying a series of elevation operations. 'secret_map' is represented as a list of non-negative integers, where each integer indicates the height of a geographic segment in a linear landscape. Each operation in the 'operations' list is defined by two integers, a start index 's' and an end index 'e', specifying that the height of each segment from index 's' to 'e' (inclusive) should be increased by 1 height unit.\n\n    Calculate and return the amount of rainwater that could be potentially trapped after all operations are applied. This simulation helps in finding hidden features within the map which might be crucial for different applications including geographical and bioinformatics research.\n\n    Example:\n    Given secret_map [2, 1, 2] and operations [[0, 1]], the revised map will be [3, 2, 2]. The predicted trapped rainwater will be 1 unit between segments 1 and 2 (due to elevation change).\n    \n    \"\"\"\n", "canonical_solution": "    def apply_operations(map_heights, operations):\n        cum_diff = [0] * (len(map_heights) + 1)\n        for s, e in operations:\n            cum_diff[s] += 1\n            if e + 1 < len(cum_diff):\n                cum_diff[e + 1] -= 1\n        added_height = 0\n        for i in range(len(map_heights)):\n            added_height += cum_diff[i]\n            map_heights[i] += added_height\n\n    def calc_trapped_water(heights):\n        left_max = [0] * len(heights)\n        right_max = [0] * len(heights)\n        water = 0\n\n        for i in range(1, len(heights)):\n            left_max[i] = max(left_max[i - 1], heights[i - 1])\n\n        for i in range(len(heights) - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], heights[i + 1])\n\n        for i in range(1, len(heights) - 1):\n            min_height = min(left_max[i], right_max[i])\n            if min_height > heights[i]:\n                water += min_height - heights[i]\n\n        return water\n\n    apply_operations(secret_map, operations)\n    return calc_trapped_water(secret_map)", "test": "def check(candidate):\n    assert candidate([2, 1, 2], [[0, 1]]) == 1\n    assert candidate([3, 0, 2, 4, 0, 3], [[1, 4]]) == 13\n    assert candidate([2, 6, 3, 8], []) == 0\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], []) == 6\n    assert candidate([0, 0, 0, 0, 0], [[0, 4], [0, 2]]) == 0", "entry_point": "treasure_map_revision", "extra_info": {"cover_story_words": ["treasure", "secret agent"], "topics": ["Trapping Rain Water"], "field": ["Bioinformatics"], "cleaned_prompt": "Write a function that receives a landscape represented by a list and a series of operations. Each operation consists of two indices defining a range. Increase the height of the landscape segments within this range by 1 unit. After applying all operations, compute and return the amount of rainwater that could be trapped between the elevated landscape segments.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Misleading Problem Context: The problem prompt refers to \"hidden features within the map\" and applications in bioinformatics and geographical research, which can mislead competitors about the expected solution. The actual task involves a computation related to a physical interpretation of trapping water, more aligned with hydrology or environmental engineering rather than the mentioned fields.", "5, Incorrect Rainwater Calculation Example: Given the example provided, [3, 0, 2, 4, 0, 3] with operations [[1, 4]], the updated heights would be [3, 1, 3, 5, 1, 3]. Following the provided rainwater trapping algorithm, the computed trapped water does not match the value of 13 as suggested by the tests.", "4, Lack of Clarity in Operations Description: The problem statement ambiguously states that the operations \"increase the height of each segment from index 's' to 'e' (inclusive) by 1 height unit\". This could confuse competitors about whether the operation at index 'e+1' decreases by 1 or remains unchanged. A more explicit explanation with an incremental example could better illustrate the mechanics of elevation operations."]}}
{"task_id": "hard/10", "prompt": "def manage_documents(documents):\n    \"\"\"\n    In a document management system, there are documents with unique identification and revision versions. Your task is to manage these documents effectively using AVL Tree and to find the longest palindromic sequence of document IDs after all insertions are complete.\n\n    Each document is represented by a tuple (document_id, revision).\n    The function should:\n    - Insert new documents into the AVL Tree.\n    - Delete documents from the AVL Tree when a revision supersedes the previous ones.\n    - Return the length of the longest palindromic sequence of the document IDs in the AVL Tree.\n\n    Input:\n    - documents: A list of tuples. Each tuple represents a document as (document_id, revision).\n\n    Output:\n    - Return the length of the longest palindromic sequence of document IDs.\n\n    Example:\n    For documents = [(1, 1), (2, 1), (3, 1), (2, 2), (1, 2), (3, 2)], the longest palindromic sequence of IDs would be [1, 2, 3, 2, 1] which has a length of 5.\n    \"\"\"\n", "canonical_solution": "    class AVLNode:\n        def __init__(self, key):\n            self.left = None\n            self.right = None\n            self.height = 1\n            self.key = key\n        def update_height(self):\n            self.height = max((self.left.height if self.left else 0), (self.right.height if self.right else 0)) + 1\n\n    class AVLTree:\n        def __init__(self):\n            self.root = None\n        def insert(self, key):\n            # Custom insert which handles revisions\n        def delete(self, key):\n            # Custom delete which handles revisions\n\n        def find_longest_palindromic_sequence(self):\n            # Convert tree keys to a list, sequence of document IDs\n            # Apply Manacher's algorithm to find longest palindrome\n\n    // Usage\n    avl_tree = AVLTree()\n    for document_id, revision in documents:\n        avl_tree.insert(document_id, revision)\n    return avl_tree.find_longest_palindromic_sequence()", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 1), (3, 1), (2, 2), (1, 2), (3, 2)]) == 5\n    assert candidate([(4, 1), (5, 1), (6, 1)]) == 1\n    assert candidate([]) == 0\n    assert candidate([(10, 1), (10, 2), (10, 3), (10, 4)]) == 1\n    assert candidate([(7, 1), (8, 1), (8, 2), (7, 2), (9, 1)]) == 5", "entry_point": "manage_documents", "extra_info": {"cover_story_words": ["document management system", "revision management"], "topics": ["AVL Tree", "Manacher's Algorithm", "Data Structures"], "field": ["Software Engineering"], "cleaned_prompt": "Write a function to manage documents using an AVL Tree for insertion and deletion. After inserting all documents, compute the longest palindromic sequence of document IDs using an efficient algorithm.\n\nInput: List of tuples (document_id, revision). Output: Length of longest palindromic sequence of document IDs.\n\nExample: For documents = [(1, 1), (2, 1), (3, 1), (2, 2), (1, 2), (3, 2)], the longest sequence would be [1, 2, 3, 2, 1] with length 5.", "warnings": ["Solution failed correctness check. reason: failed: expected an indented block (<string>, line 34)", "5, Ambiguity in Problem Requirements: The problem prompt and example suggest handling both document numbers and revision numbers, but the details and method for handling revisions operationally (e.g., version control, how they affect the tree structure, order, etc.) are not specified. This lack of clarity can lead to multiple interpretations and implementations, which is problematic for ensuring consistent solutions among participants.", "4, Misuse of Data Structures: The use of an AVL Tree to track document numbers and then extracting these numbers to find the longest palindromic sequence using Manacher's algorithm seems inefficient and inappropriate. AVL Trees are meant for fast lookups, insertions, and deletions, not for operations on sequential data like finding palindromes, which could be more directly and efficiently handled using other data structures or methods specifically suited for sequence analysis.", "4, Incomplete Solution Template: The canonical solution provided lacks complete implementation details (e.g., the AVLTree _insert, _delete methods and Manacher's algorithm implementation are omitted), which can confuse participants about the expected level of detail and specific AVL and algorithmic knowledge required."]}}
{"task_id": "medium/2", "prompt": "def escape_dungeon(dungeon_map):\n    \"\"\"\n    Given a grid where each cell can either be passable ('.') or blocked by an obstacle ('#'), find a probable escape path from the top-left corner (start) to the bottom-right corner (exit). Use a probabilistic approach, specifically a randomized version of Depth-First Search (DFS), to find one of the possible paths.\n\n    The function should return a list of tuples representing the path from start to exit, each tuple containing the coordinates (row, column) of a cell in the path.\n\n    Parameters:\n    `dungeon_map`: List of strings where each string represents a row of the dungeon grid.\n\n    Example:\n    For dungeon_map=['.#.', '..#', '#..'], a valid output could be [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)].\n\n    Note:\n    - The selected path should not revisit cells.\n    - The solution should effectively utilize randomness to simulate decision making under uncertainty.\n    \"\"\"\n", "entry_point": "escape_dungeon", "canonical_solution": "\timport random\n\n\tdef is_valid(x, y, n, m):\n\t    return 0 <= x < n and 0 <= y < m\n\n\tdef escape_dungeon(dungeon_map):\n\t    n, m = len(dungeon_map), len(dungeon_map[0])\n\t    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\t    stack = [(0, 0)]\n\t    visited = set(stack)\n\t    path = []\n\n\t    while stack:\n\t        current = stack.pop()\n\t        path.append(current)\n\t        if current == (n-1, m-1):\n\t            return path\n\n\t        possible_moves = []\n\t        for dx, dy in directions:\n\t            nx, ny = current[0] + dx, current[1] + dy\n\t            if is_valid(nx, ny, n, m) and (nx, ny) not in visited and dungeon_map[nx][ny] == '.':\n\t                possible_moves.append((nx, ny))\n\n\t        if possible_moves:\n\t            chosen = random.choice(possible_moves)\n\t            stack.append(chosen)\n\t            visited.add(chosen)\n\n\t    return path\n", "test": "def check(candidate):\n\n\tassert len(candidate(['.#.', '..#', '#..'])) >= 3\n\tassert len(candidate(['...', '...', '...'])) >= 3\n\tassert candidate(['###', '#.#', '###']) == [(0, 0)]\n\tassert len(candidate(['.#.', '...', '.#.'])) >= 3\n\tassert len(candidate(['...', '.#.', '...'])) >= 3", "extra_info": {"cover_story_words": ["dungeon", "grid"], "topics": ["Depth-First Search", "Randomized Algorithms"], "field": ["Pathfinding"], "cleaned_prompt": "Create a function to find an escape path from a grid-based dungeon using a randomized Depth-First Search (DFS). Each cell in the grid is either passable ('.') or blocked ('#'). The path should not revisit cells and should effectively utilize randomness.", "warnings": ["Solution failed correctness check. reason: failed: inconsistent use of tabs and spaces in indentation (<string>, line 17)", "4, Misleading Problem Constraints: The prompt suggests that the function should be a 'probabilistic' or randomized approach, but the use of randomness isn't well-explicit in either the problem statement or in the example provided, aside from a simple random choice among possible moves. The function should have more complexity or explanation on how randomness significantly affects the path computation beyond trivial decision-making among equivalently valid options.", "5, Test Cases Not Covering Key Edge Cases: The test cases provided do not account for several edges cases such as very large grids, all cells blocked except start and end, or shapes of the grid differing (e.g., non-rectangle shapes or having several disconnected sections). Such limitations in the test might lead to solutions passing without properly handling all feasible real-world scenarios that the function should account for."]}}
{"task_id": "hard/6", "prompt": "def count_artifacts(grid):\n    \"\"\"\n    Suppose you are in a fairy tale world where there has just been a supernatural storm that has scattered magical artifacts all over a kingdom represented by a 2D grid. Each cell in this grid can either be empty (0) or contain part of a magical artifact (1).\n\n    Magical artifacts can be spread over multiple cells but will always form a linear horizontal or vertical segment. Fortunately, the artifacts remain intact in their segments post-storm.\n\n    Your task is to determine how many distinct artifacts are there in the grid. Each artifact is a continuous line of '1's vertically or horizontally. Connections are not counted diagonally. Furthermore, each '1' in the grid is part of exactly one artifact.\n\n    The grid is guaranteed to have dimensions between 1x1 and 500x500.\n\n    Example:\n    For the grid:\n        [\n            [1, 0, 0, 1, 1],\n            [1, 0, 0, 1, 1],\n            [0, 0, 1, 0, 0],\n            [0, 1, 1, 0, 1]\n        ]\n    The function should return 6, as there are six distinct artifacts:\n        - Two vertical artifacts of length 2 at the first and fourth column.\n        - Two horizontal artifacts of length 2 at the fourth row.\n        - One vertical artifact of length 1 in the third row, third column.\n        - One horizontal artifact of length 1 in the third row.\n    \"\"\"\n", "canonical_solution": "    def count_artifacts(grid):\n        if not grid or not grid[0]:\n            return 0\n\n        rows, cols = len(grid), len(grid[0])\n        visited = [[False] * cols for _ in range(rows)]\n        count = 0\n\n        def dfs(r, c, direction):\n            if direction == 'horizontal':\n                while c < cols and grid[r][c] == 1 and not visited[r][c]:\n                    visited[r][c] = True\n                    c += 1\n            else:  # direction == 'vertical'\n                while r < rows and grid[r][c] == 1 and not visited[r][c]:\n                    visited[r][c] = True\n                    r += 1\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1 and not visited[r][c]:\n                    if c == 0 or grid[r][c-1] == 0:\n                        dfs(r, c, 'horizontal')\n                        count += 1\n                    if r == 0 or grid[r-1][c] == 0:\n                        dfs(r, c, 'vertical')\n                        count += 1\n        return count", "test": "def check(candidate):\n    assert candidate([[1, 0, 0, 1, 1], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 1, 1, 0, 1]]) == 6\n    assert candidate([[1, 1, 0, 1], [1, 1, 0, 1], [0, 0, 1, 1]]) == 3\n    assert candidate([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 5\n    assert candidate([[1]]) == 1\n    assert candidate([[0,0,0,0],[0,0,0,0]]) == 0", "entry_point": "count_artifacts", "extra_info": {"cover_story_words": ["supernatural storm", "fairy tale"], "topics": ["Counting Sort", "Line Sweep"], "field": ["Computer Vision"], "cleaned_prompt": "Write a function that receives a 2D grid, each cell in the grid being either empty (0) or contain part of a magical artifact (1). Artifacts form continuous horizontal or vertical segments of '1's. Your function should count and return the number of distinct magical artifacts in the grid. Artifacts do not connect diagonally and each '1' belongs to exactly one artifact. For example, in a grid [[1, 1, 0], [0, 0, 0], [1, 0, 1]], the count of artifacts would be 3.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Logical flaw in algorithm implementation: The provided canonical solution has a critical logical flaw where it checks cell-by-cell for starting new artifacts both horizontally and vertically without proper conditions to determine the actual start of an artifact. This approach leads to the double-counting of artifacts that can start from intersecting horizontal and vertical lines. This violates the constraint where each '1' in the grid is part of exactly one artifact. The DFS function is incorrectly initialized for every '1' that follows an empty cell or edge cell, regardless of whether it's part of an already counted segment or starting a new unique segment, particularly when such a cell could be reached through horizontal and vertical paths simultaneously."]}}
{"task_id": "hard/3", "prompt": "def frontier_vortex_energy_distribution(vortices, queries):\n    \"\"\"\n    In a fictional Wild West world, energy is distributed through interdimensional vortices arranged in a special kind of Binary Search Tree called the Frontier Vortex Energy Tree (FVET). Each node in this tree represents a vortex and is identified by a unique transaction ID processed through a blockchain network. Each node holds information about its energy level.\n\n    Given the transaction IDs, in the form of BST node keys, and associated energy levels, construct this Binary Search Tree. Once the tree is constructed, your task is to perform a series of energy range queries. An energy range query specifies a lower and upper transaction ID boundary and asks for the total energy within this range.\n\n     Each query is represented as a tuple (low, high), where low and high are the transaction IDs marking the boundary of the query. You need to efficiently calculate the total energy contained in the nodes within this boundary using augmented properties for faster range sum calculations.\n\n    Example:\n    vortices = [(5, 30), (3, 20), (8, 40), (1, 10), (4, 25), (7, 35)]\n    queries = [(1, 4), (3, 7)]\n    - For the range (1, 4), the expected energy sum is 55 (10 from node 1, 20 from node 3, and 25 from node 4).\n    - For the range (3, 7), the expected energy sum is 80 (20 from node 3, 25 from node 4, and 35 from node 7).\n\n    Note:\n    - The BST nodes' keys are unique positive integers that represent transaction IDs.\n    - Nodes' keys and energy levels are given as tuples (key, energy).\n    \"\"\"", "entry_point": "frontier_vortex_energy_distribution", "canonical_solution": "    class TreeNode:\n        def __init__(self, key, energy):\n            self.key = key\n            self.energy = energy\n            self.left = None\n            self.right = None\n            self.subtree_energy_sum = energy  # Augmented property for subtree sum\n\n    def insert_bst(root, key, energy):\n        if not root:\n            return TreeNode(key, energy)\n        elif key < root.key:\n            root.left = insert_bst(root.left, key, energy)\n            root.subtree_energy_sum += energy\n        else:\n            root.right = insert_bst(root.right, key, energy)\n            root.subtree_energy_sum += energy\n        return root\n\n    def sum_range(node, low, high):\n        if not node:\n            return 0\n        if low <= node.key <= high:\n            total_energy = node.energy\n            total_energy += sum_range(node.left, low, high)\n            total_energy += sum_range(node.right, low, high)\n        else:\n            total_energy = 0\n            if node.key > low:\n                total_energy += sum_range(node.left, low, high)\n            if node.key < high:\n                total_energy += sum_range(node.right, low, high)\n        return total_energy\n\n    root = None\n    for key, energy in vortices:\n        root = insert_bst(root, key, energy)\n    results = [sum_range(root, q[0], q[1]) for q in queries]\n    return results", "test": "def check(candidate):\n    # Test case 1\n    vortices = [(5, 30), (3, 20), (8, 40), (1, 10), (4, 25), (7, 35)]\n    queries = [(1, 4), (3, 7)]\n    assert candidate(vortices, queries) == [55, 80]\n    # Test case 2\n    vortices = [(10, 100), (5, 50), (15, 150), (3, 30), (7, 70), ...]", "extra_info": {"cover_story_words": ["energy vortex", "wild west"], "topics": ["Binary Search Tree", "Augmented BST"], "field": ["Blockchain Technology"], "cleaned_prompt": "Given pairs of transaction IDs and energy, construct an augmented Binary Search Tree. For given range queries on transaction IDs, efficiently compute the total energy within each range. Examples clarify the construction and querying processes in the BST, illustrating use of the augmented properties for enhanced performance.", "warnings": ["Only 1 test cases found. Minimum recommended is 5.", "Solution failed correctness check. reason: failed: invalid syntax (<string>, line 18)", "5, Incorrect example explanation: The problem statement contains inconsistencies in the example explanation, particularly how the energy sums are calculated for the provided range queries. The explanation does not match provided data, causing potential misunderstanding and confusion for the solver.", "5, Inefficient algorithm guidance: The recommended approach provided in the canonical solution appears inefficient, especially for large datasets. It uses simple traversal for summing node ranges without leveraging the BST properties effectively or recommending more sophisticated methods that could operate more efficiently, such as self-balancing trees or augmented BSTs.", "4, Unrealistic problem cover story: The narrative involving \"interdimensional vortices\" and \"Frontier Vortex Energy Tree\" in a \"Wild West world\" feels thematically disjointed and could be confusing. This over-complexity in the storyline might detract from the core task, making it harder for participants to focus on the actual algorithmic challenges.", "4, Missing complexity and constraint details: The problem lacks detail on critical constraints such as the number of vortices, number of queries, the range of transaction IDs, and energy levels. This omission hinders the ability to effectively gauge the expected efficiency and difficulty of the problem, complicating both solution planning and testing."]}}
{"task_id": "hard/7", "prompt": "def fairies_schedule_management(cafe_times, fairness_relations):\n    \"\"\"\n    In a cyber cafe famous amongst students, mischievous metaphysical entities - fairies, play around with the cafe's course schedule. This cyber cafe offers special courses on various advanced topics including computer vision which the students need to complete in a specified order based on their complexity.\n\n    However, due to the antics of these fairies, the schedule might now have cycles due to swapped courses. Your task is to determine if all courses can still be completed without any cyclic dependencies after considering the fairies' swaps.\n\n    You're given:\n    - cafe_times: which are tuples (a, b) indicating course 'a' needs to be finished before course 'b' can be started.\n    - fairness_relations: a list of pairs (fa, fb) indicating that the ordering of courses 'fa' and 'fb' have been swapped.\n\n    This involves modifying the graph structure by reversing the direction of the edges specified in the fairness_relations and then checking for cycles using Tarjan's Algorithm.\n\n    Example:\n    If cafe_times = [(1, 2), (2, 3), (3, 4)] and fairness_relations = [(2, 3)], applying the swaps results in the pair: (3, 2), and the graph should be checked for cycles.\n\n    Note:\n    - It's guaranteed that the input lists will not have repeat elements.\n    - Assume all courses are labeled with unique integers starting from 1.\n\n    \"\"\"", "canonical_solution": "    def tarjan(v, adj_list):\n        index = 0\n        stack = []\n        indices = [-1] * (v + 1)\n        lowlink = [0] * (v + 1)\n        result = []\n        on_stack = [False] * (v + 1)\n\n        def strongconnect(node):\n            nonlocal index\n            indices[node] = index\n            lowlink[node] = index\n            index += 1\n            stack.append(node)\n            on_stack[node] = True\n\n            for neighbor in adj_list[node]:\n                if indices[neighbor] == -1:\n                    strongconnect(neighbor)\n                    lowlink[node] = min(lowlink[node], lowlink[neighbor])\n                elif on_stack[neighbor]:\n                    lowlink[node] = min(lowlink[node], indices[neighbor])\n\n            if lowlink[node] == indices[node]:\n                connected_component = []\n                while True:\n                    w = stack.pop()\n                    on_stack[w] = False\n                    connected_component.append(w)\n                    if w == node:\n                        break\n                result.append(connected_component)\n\n        for i in range(1, v + 1):\n            if indices[i] == -1:\n                strongconnect(i)\n        return any(len(c) > 1 for c in result)\n\n    from collections import defaultdict\n    adj_list = defaultdict(list)\n    max_vertex = 0\n    for a, b in cafe_times:\n        adj_list[a].append(b)\n        max_vertex = max(max_vertex, a, b)\n    for fa, fb in fairness_relations:\n        adj_list[fa].remove(fb)\n        adj_list[fb].append(fa)\n\n    return not tarjan(max_vertex, adj_list)", "test": "def check(candidate):\n    # Test cases including the examples from the prompt\n    assert candidate([(1, 2), (2, 3), (3, 4)], [(2, 3)]) == True\n    assert candidate([(1, 2), (2, 3), (3, 1)], []) == False\n    assert candidate([(1, 2), (2, 3), (4, 3)], [(3, 4)]) == True\n    assert candidate([(1, 2), (2, 3), (3, 4)], [(1, 3), (3, 1)]) == False\n    assert candidate([(1, 2), (2, 3), (3, 1)], [(1, 3)]) == False", "entry_point": "fairies_schedule_management", "extra_info": {"cover_story_words": ["cyber cafe", "mischievous fairies"], "topics": ["Course Schedule", "Tarjan's Algorithm"], "field": ["Computer Vision"], "cleaned_prompt": "Given a list of course prerequisites and a list of course swaps due to fairies' mischiefs, determine if the courses can be completed in a valid order using Tarjan's Algorithm to detect cycles.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 20)", "5, Ambiguity in Output: The problem statement does not clearly define the expected output format. The description suggests determining if all courses can still be completed without any cyclic dependencies, but does not specify if the function should return a boolean (True or False) or another type of output indicating the result. This could lead to wrong implementations since programmers might be unclear about what specific output needs to be returned.", "5, Inconsistent Test Case Output Expectations: The provided test cases in the 'test' section appear to expect boolean outputs (True or False) directly contradicting the undefined output format in the prompt. Such inconsistency can confuse contestants about the expected function behavior and implementation specifics.", "5, Incorrect Implementation Example: In the canonical solution provided, there's an attempt to modify an adjacency list by removing edges and adding the reversed edges for fairness_relations. This could potentially throw errors if an edge being reversed does not exist in the original graph. The algorithm could attempt to remove a non-existent edge from the adjacency list, potentially causing runtime errors.", "4, Unhandled Edge Case in Solution: The solution given does not consider the scenario where a fairness relation specifies a swap (fa, fb) for nodes that aren't connected directly, leading to an incorrect removal of an edge. This may result in misrepresentation of the graph's structure, thereby affecting the cycle detection logic."]}}
{"task_id": "hard/4", "prompt": "def mystical_chain_combinations(start, blocks, K):\n    \"\"\"\n    In a mystical jungle combined with fairy tale elements, there's a blockchain that controls magical barriers. The blockchain consists of blocks represented as nodes in a doubly linked list. Each node contains a magic number. In the world of fairy tales, you find some blocks in the form of a doubly linked list starting from the given block 'start'.\n\n    The kingdom's emperor is pondering about the security of their realm. He wants to calculate how many secure blockchain combinations can be generated from the given set of blocks. A combination is called secure if the product of the magic numbers from the selected blocks in a sequence is not divisible by the given integer 'K'.\n\n    Write a function that calculates how many secure combinations of the doubly linked list blocks can be made from a continuous sequence of blocks such that no combination's product of magic numbers is divisible by 'K'. The sequences should be unique (i.e., different starting or ending block).\n\n    Note:\n    - Constraints: List size (1 <= size <= 1000), Magic numbers (1 <= magic number <= 10^9), K (1 <= K <= 10^9).\n    - If 'start' is None or there are not enough blocks to form any sequence, return 0.\n    - Start could be any block and can traverse forward or backwards using the doubly-linked nature.\n    - Assume that each function call will provide enough blocks that can generate at least one valid combination.\n    \"\"\"\n", "entry_point": "mystical_chain_combinations", "canonical_solution": "    def is_magic_product_secure(blocks, K):\n        count_secure = 0\n        n = len(blocks)\n        for start in range(n):\n            product = 1\n            for end in range(start, n):\n                product *= blocks[end]\n                if product % K != 0:\n                    count_secure += 1\n        return count_secure\n\n    # Convert linked list to list\n    numbers = []\n    ptr = start\n    if not ptr:\n        return 0\n    while ptr:\n        numbers.append(ptr.magic)\n        ptr = ptr.next\n\n    return is_magic_product_secure(numbers, K)", "test": "def check(candidate):\n    class Node:\n        def __init__(self, magic, next=None, prev=None):\n            self.magic = magic\n            self.next = next\n            self.prev = prev\n\n    # Creating the doubly linked list from array\n    def create_doubly_linked_list(arr):\n        head = Node(arr[0])\n        current = head\n        if len(arr) == 1:\n            return head\n        for num in arr[1:]:\n            new_node = Node(num)\n            current.next = new_node\n            new_node.prev = current\n            current = new_node\n        return head\n\n    # Test cases\n    blocks1 = create_doubly_linked_list([1, 2, 3, 4])\n    assert candidate(blocks1, 2) == 4\n\n    blocks2 = create_doubly_linked_list([7, 11, 13, 17])\n    assert candidate(blocks2, 5) == 15\n\n    blocks3 = create_doubly_linked_list([2, 4, 6, 8, 10])\n    assert candidate(blocks3, 3) == 0\n\n    blocks4 = create_doubly_linked_list([3, 6, 1, 5])\n    assert candidate(blocks4, 2) == 11\n\n    blocks5 = create_doubly_linked_list([19, 23, 29, 31])\n    assert candidate(blocks5, 7) == 15", "extra_info": {"cover_story_words": ["jungle", "fairy tale"], "topics": ["Doubly-Linked List", "Combinatorics"], "field": ["Blockchain Technology"], "cleaned_prompt": "Write a function 'mystical_chain_combinations' that takes in 'start', a node of a doubly linked list representing a chain of magical blocks, and a number 'K'. The function should return the number of unique, secure combinations of blocks.\n\n    A sequence of blocks is secure if the product of their numbers (magic numbers) is not divisible by 'K'. Every block has a 'magic' number. 'Start' indicates the initial block, and blocks can be accessed forwards and backwards. Return count of all secure sequences.\n\n    Note:\n    - Constraints: List size (1 <= size <= 1000), Magic numbers (1 <= magic number <= 10^9), K (1 <= K <= 10^9).", "warnings": ["Solution failed correctness check. reason: failed: mystical_chain_combinations() missing 1 required positional argument: 'K'", "5, Inconsistent Behavior with Assumptions: The prompt states that \"Assume that each function call will provide enough blocks that can generate at least one valid combination,\" but the canonical solution explicitly handles cases where `start` is `None` or the blockchain is too short, returning `0`. This contradiction might lead to confusion for users as to what scenarios the function should correctly handle.", "4, Unclear Execution with Backward Traversal: Although the prompt mentions the ability to traverse backward due to the doubly-linked nature of the list, the provided solution and further problem details do not specify how backward traversal affects the counting of combinations or its implementation. This omission could leave participants unsure of how to effectively incorporate this functionality into their solutions."]}}
{"task_id": "hard/8", "prompt": "def hot_air_balloon_courtroom_decision(balloon_images, proposals):\n    \"\"\"\n    Imagine we are trying to decide on the design for a new series of hot air balloons to be used in courtrooms as a novelty method to resolve certain types of cases efficiently. Each design proposal for these balloons is based on various characteristics captured in images.\n\n    Your task is to write a function that takes in a list of images of balloon proposals (each image is represented as a 2D matrix of pixels) and a list of proposals (each represented as a dictionary containing an 'id' and an 'area' within an image that likely contains significant design elements).\n\n    The function should rank each proposal by its effectiveness in a courtroom, based on the clarity and informativeness of content within the proposed 'area'. You must use computer vision concepts such as image clarity measurement or key feature extraction to quantitatively measure these attributes.\n\n    For each proposal, if the 'id' does not match any in balloon_images, it should be flagged as 'invalid'.\n\n    For example, if `balloon_images` are [{'id': 1, 'image': [[0, 255], [255, 0]]}], and `proposals` are [{'id': 1, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}], the effectiveness can be computed using statistical variance or other relevant metrics.\n\n    Note:\n    - All input is expected to be valid and well-formed according to the specification.\n    - The 'area' in proposals is specified as a dictionary with 'top_left' (x, y) and 'bottom_right' (x, y) coordinates of the rectangle.\n    \"\"\"", "canonical_solution": "    def extract_area(image, area):\n        x1, y1 = area['top_left']\n        x2, y2 = area['bottom_right']\n        return [row[x1:x2+1] for row in image[y1:y2+1]]\n\n    def calculate_effectiveness(subimage):\n        import numpy as np\n        arr = np.array(subimage)\n        return np.var(arr)\n\n    balloon_dict = {balloon['id']: balloon['image'] for balloon in balloon_images}\n\n    proposal_effectiveness = []\n    for proposal in proposals:\n        if proposal['id'] not in balloon_dict:\n            proposal_effectiveness.append({'id': proposal['id'], 'effectiveness': 'invalid'})\n            continue\n        image = balloon_dict[proposal['id']]\n        area = proposal['area']\n        subimage = extract_area(image, area)\n        effectiveness = calculate_effectiveness(subimage)\n        proposal_effectiveness.append({'id': proposal['id'], 'effectiveness': effectiveness})\n\n    sorted_proposals = sorted(proposal_effectiveness, key=lambda x: x['effectiveness'] if isinstance(x['effectiveness'], float) else float('-inf'), reverse=True)\n    return sorted_proposals", "test": "def check(candidate):\n    assert candidate([\n        {'id': 1, 'image': [[100, 100], [100, 100]]}\n    ], [\n        {'id': 1, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 1, 'effectiveness': 0.0}]\n\n    assert candidate([\n        {'id': 2, 'image': [[255, 0], [0, 255]]},\n        {'id': 3, 'image': [[10, 100], [200, 50]]}\n    ], [\n        {'id': 2, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}},\n        {'id': 3, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 3, 'effectiveness': 5775.0}, {'id': 2, 'effectiveness': 10406.25}]\n\n    assert candidate([\n        {'id': 4, 'image': [[30, 60], [70, 90]]}\n    ], [\n        {'id': 4, 'area': {'top_left': (0, 0), 'bottom_right': (0, 0)}}\n    ]) == [{'id': 4, 'effectiveness': 0.0}]\n\n    assert candidate([\n        {'id': 5, 'image': [[100, 255], [255, 100]]}\n    ], [\n        {'id': 5, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 5, 'effectiveness': 7246.25}]\n\n    assert candidate([\n        {'id': 6, 'image': [[0, 200], [200, 0]]}\n    ], [\n        {'id': 6, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 6, 'effectiveness': 10000.0}]", "entry_point": "hot_air_balloon_courtroom_decision", "extra_info": {"cover_story_words": ["hot air balloon", "courtroom"], "topics": ["Subsets", "Quickselect"], "field": ["Computer Vision"], "cleaned_prompt": "Write a function that processes a list of images of balloon proposals (each image as a 2D pixel matrix) and proposals (each as a dictionary with 'id' and rectangle 'area'). Rank the proposals by courtroom effectiveness based on the clarity and informativeness of each 'area', using quantitative computer vision techniques. Flag proposals with non-matching 'id' as 'invalid'.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 16)", "5, Impractical scenario: The premise of using hot air balloon designs in courtrooms for case resolution is highly impractical and does not relate closely enough to real-world applications or typical problem-solving scenarios expected in coding competitions. This could confuse participants and detract from the problem's educational value.", "4, Misalignment with noted topics: The problem statement includes \"Subsets\" and \"Quickselect\" as topics, but neither of these seems directly relevant to the primary task, which focuses on image processing and basic computational assessment of images. This may mislead participants regarding the skills and knowledge they should apply."]}}
