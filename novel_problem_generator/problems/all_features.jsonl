{"task_id": "hard/2", "prompt": "def enchanted_invisibility_cloak(serial_codes):\n    \"\"\"\n    In an enchanted marketplace, invisibility cloaks are encoded with magical serial codes. Each serial code is a string made up of lowercase English letters. The enchantment's power is determined by the ability to partition the serial code into the smallest possible number of palindromic substrings.\n\n    A palindromic substring is a sequence of characters which reads the same backward as forward.\n\n    Write a function `enchanted_invisibility_cloak` that takes a list of serial codes and returns a list where each element corresponds to the minimal number of palindromic substrings the respective serial code can be partitioned into.\n\n    Example:\n    If the input is ['abc', 'aabb', 'racecar', 'madam'], the output should be [3, 2, 1, 1].\n    - 'abc' can be partitioned as ['a', 'b', 'c'] (3 parts)\n    - 'aabb' can be parted as ['aa', 'bb'] (2 parts)\n    - 'racecar' is already a palindrome (1 part)\n    - 'madam' is already a palindrome (1 part)\n\n    Notes:\n    - Assume all input strings are non-empty and consist only of lowercase English characters.\n    \"\"\"\n    # Implementation here", "canonical_solution": "def enchanted_invisibility_cloak(serial_codes):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def min_partitions(string):\n        n = len(string)\n        if is_palindrome(string):\n            return 1\n        # Create a DP array\n        dp = [0] * (n + 1)\n        # Base case\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            min_cut = float('inf')\n\n            for j in range(1, i + 1):\n                if is_palindrome(string[i-j:i]):\n                    min_cut = min(min_cut, dp[i-j] + 1)\n\n            dp[i] = min_cut\n\n        return dp[n]\n    return [min_partitions(code) for code in serial_codes]", "test": "def check(candidate):\n    assert candidate(['abc']) == [3]\n    assert candidate(['aabb', 'racecar']) == [2, 1]\n    assert candidate(['madam', 'noon', 'xyz']) == [1, 1, 3]\n    assert candidate(['level', 'civic', 'deified']) == [1, 1, 1]\n    assert candidate(['ab', 'aa', 'aba']) == [2, 1, 1]", "entry_point": "enchanted_invisibility_cloak", "extra_info": {"cover_story_words": ["invisibility cloak", "enchanted marketplace"], "topics": ["Palindrome Partitioning"], "field": "", "cleaned_prompt": "def enchanted_invisibility_cloak(serial_codes):\n    \"\"\"\n    Takes a list of serial codes and returns a list of the minimal number of palindromic substrings each code can be partitioned into.\n\n    A palindromic substring is a sequence of characters which reads the same backward as forward.\n\n    Examples:\n    - Input: ['abc'], Output: [3]\n    - Input: ['aabb', 'racecar'], Output: [2, 1]\n    - Input: ['madam', 'noon', 'xyz'], Output: [1, 1, 3]\n\n    Assume all strings only contain lowercase letters and are non-empty.\n    \"\"\"", "warnings": ["5, Ambiguity in Solution Example: The problem ambiguously describes the expected output format for the partition process, focusing mainly on the number of partitions required for palindromic substrings without explicit rules or guidelines on how substrings are chosen in serial codes with multiple valid partitions. This could lead to multiple valid outputs based on differing interpretations, affecting grading and validation systems."]}}
{"task_id": "hard/9", "prompt": "def magical_gallery(arr):\n    \"\"\"\n    In an enchanted art gallery, each piece of art has a value that changes daily. The curator of the gallery wants to know if there is any combination of three art pieces whose values sum up to zero. Your task is to write a function 'magical_gallery' that takes a list of integers representing today's values of art pieces and returns a list of unique triplets [a, b, c] from the list such that a + b + c = 0. Each triplet should be sorted in non-descending order, and the result list should also be sorted accordingly.\n\n    Example:\n    Input: [-1, 0, 1, 2, -1, -4]\n    Output: [[-1, -1, 2], [-1, 0, 1]]\n\n    Note:\n    - The input list can include duplicates which may lead to duplicate triplets if not handled.\n    - The result should not contain duplicate triplets.\n    - If no such triplet exists, return an empty list.\n    \"\"\"\n", "canonical_solution": "    arr.sort()\n    result = []\n    for i in range(len(arr)):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        left, right = i + 1, len(arr) - 1\n        while left < right:\n            sum = arr[i] + arr[left] + arr[right]\n            if sum == 0:\n                result.append([arr[i], arr[left], arr[right]])\n                while left < right and arr[left] == arr[left + 1]:\n                    left += 1\n                while left < right and arr[right] == arr[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif sum < 0:\n                left += 1\n            else:\n                right -= 1\n    return result", "test": "def check(candidate):\n    assert candidate([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]]\n    assert candidate([0, 0, 0, 0]) == [[0, 0, 0]]\n    assert candidate([3, -1, -7, 2, -4, 10]) == []\n    assert candidate([34, -21, -36, 22, 14, -49, 10, 25]) == [[-21, -36, 10, 25]]\n    assert candidate([1, 2, -3, 0, 5, 7, -2, -1]) == [[-3, 1, 2], [-2, -1, 3]]", "entry_point": "magical_gallery", "extra_info": {"cover_story_words": ["crystal ball", "art gallery"], "topics": ["3-Sum Problem"], "field": ["Reinforcement Learning"], "cleaned_prompt": "Given a list of integers representing the values for today's art pieces in a gallery, return all unique triplets where the sum of their values is zero and each triplet is sorted in non-descending order. If no such triplet exists, return an empty list. Each triplet should be unique, and the result list should be sorted.\n\nExample:\nInput: [-1, 0, 1, 2, -1, -4]\nOutput: [[-1, -1, 2], [-1, 0, 1]]", "warnings": ["Solution failed correctness check. reason: failed: ", "4, ambiguous_output_format: The output format specification and example do not clearly specify if the output triplets must always be sorted within each individual triplet as well as the entire list of triplets sorted among themselves. This ambiguity can lead to variations in valid outputs that could be considered incorrect if not consistently defined.", "5, logical_error_in_example: In the provided examples within the 'test' section, some of the outputs mentioned do not correctly sum up to zero, creating a misconception or misleading guidance for anyone developing or testing similar functions as the one described. This could challenge the validity and reliability of assuming the problem statement and example outputs are correct, leading to erroneous implementations."]}}
{"task_id": "hard/5", "prompt": "def sentinel_rock_cipher(message, rocks):\n    \"\"\"\n    Write a function that takes a string message and a list of integers rocks. Each integer in rocks represents a valued rock. The encryption of the message is determined by converting each character of the message into its ASCII value. Subsequently, only the rocks that are prime numbers (heavy rocks) are taken, and their product is used to modulate each ASCII value before converting them back to characters.\n\n    If there are no prime numbers in rocks (no heavy rocks), the function should return the original message.\n\n    This encryption ensures that the characters are shuffled in a way that their new values are the remainder when their ASCII values are divided by the product of the heavy rocks.\n\n    Examples:\n    - If rocks are [2, 3, 6, 7, 10], the heavy rocks are [2, 3, 7]. The product of these prime-valued rocks is 42. Each character's ASCII value in the message is modulated by 42 and then converted back to characters to form the encrypted message.\n    - If there are no heavy rocks, like in rocks = [4, 6, 8], the original message is returned.\n\n    Note: The function might return non-printable or special characters as part of the encrypted message due to the modulation operation.\n    \"\"\"\n", "entry_point": "sentinel_rock_cipher", "canonical_solution": "    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    modulus = 1\n    for rock in rocks:\n        if is_prime(rock):\n            modulus *= rock\n    if modulus == 1:\n        return message\n    else:\n        encrypted_message = ''.join(chr(ord(char) % modulus) for char in message)\n        return encrypted_message", "test": "def check(candidate):\n    assert candidate(\"Hello, world!\", [2, 3, 6, 7, 10]) == \"]6JU!I12JU@\"\n    assert candidate(\"Desert rocks\", [11, 13, 16]) == \"3M46C1*3CK2\"\n    assert candidate(\"No primes\", []) == \"No primes\"\n    assert candidate(\"abc\", [999]) == \"abc\"\n    assert candidate(\"12345\", [2, 5, 7, 11]) == \"N)*+*\"\n    assert candidate(\"Test with non-prime\", [4, 6, 8, 10]) == \"Test with non-prime\"", "extra_info": {"cover_story_words": ["desert", "sentient rocks"], "topics": ["Cryptography", "Number Theory"], "field": ["Cybersecurity"], "cleaned_prompt": "Write a function sentinel_rock_cipher(message, rocks) that takes a message (string) and rocks (list of integers). Encrypt the message by converting each character to its ASCII value and then modulating by the product of the prime-values in rocks, converting the result back to characters. If there are no prime values in rocks, return the original message.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, Overflow risk in product of heavy rocks: There is no safeguard in the function against overflow or extremely large values when calculating the product of prime-valued rocks ('heavy rocks'). This could lead to incorrect results or runtime errors due to integer overflow, especially for large inputs."]}}
{"task_id": "hard/1", "prompt": "def treasure_map_revision(secret_map, operations):\n    \"\"\"\n    Revise a given 'secret_map' to determine the hypothetical amount of rainwater that could be trapped between the map's segments after applying a series of elevation operations. 'secret_map' is represented as a list of non-negative integers, where each integer indicates the height of a geographic segment in a linear landscape. Each operation in the 'operations' list is defined by two integers, a start index 's' and an end index 'e', specifying that the height of each segment from index 's' to 'e' (inclusive) should be increased by 1 height unit.\n\n    Calculate and return the amount of rainwater that could be potentially trapped after all operations are applied. This simulation helps in finding hidden features within the map which might be crucial for different applications including geographical and bioinformatics research.\n\n    Example:\n    Given secret_map [2, 1, 2] and operations [[0, 1]], the revised map will be [3, 2, 2]. The predicted trapped rainwater will be 1 unit between segments 1 and 2 (due to elevation change).\n    \n    \"\"\"\n", "canonical_solution": "    def apply_operations(map_heights, operations):\n        cum_diff = [0] * (len(map_heights) + 1)\n        for s, e in operations:\n            cum_diff[s] += 1\n            if e + 1 < len(cum_diff):\n                cum_diff[e + 1] -= 1\n        added_height = 0\n        for i in range(len(map_heights)):\n            added_height += cum_diff[i]\n            map_heights[i] += added_height\n\n    def calc_trapped_water(heights):\n        left_max = [0] * len(heights)\n        right_max = [0] * len(heights)\n        water = 0\n\n        for i in range(1, len(heights)):\n            left_max[i] = max(left_max[i - 1], heights[i - 1])\n\n        for i in range(len(heights) - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], heights[i + 1])\n\n        for i in range(1, len(heights) - 1):\n            min_height = min(left_max[i], right_max[i])\n            if min_height > heights[i]:\n                water += min_height - heights[i]\n\n        return water\n\n    apply_operations(secret_map, operations)\n    return calc_trapped_water(secret_map)", "test": "def check(candidate):\n    assert candidate([2, 1, 2], [[0, 1]]) == 1\n    assert candidate([3, 0, 2, 4, 0, 3], [[1, 4]]) == 13\n    assert candidate([2, 6, 3, 8], []) == 0\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], []) == 6\n    assert candidate([0, 0, 0, 0, 0], [[0, 4], [0, 2]]) == 0", "entry_point": "treasure_map_revision", "extra_info": {"cover_story_words": ["treasure", "secret agent"], "topics": ["Trapping Rain Water"], "field": ["Bioinformatics"], "cleaned_prompt": "Write a function that receives a landscape represented by a list and a series of operations. Each operation consists of two indices defining a range. Increase the height of the landscape segments within this range by 1 unit. After applying all operations, compute and return the amount of rainwater that could be trapped between the elevated landscape segments.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Misleading Problem Context: The problem prompt refers to \"hidden features within the map\" and applications in bioinformatics and geographical research, which can mislead competitors about the expected solution. The actual task involves a computation related to a physical interpretation of trapping water, more aligned with hydrology or environmental engineering rather than the mentioned fields.", "5, Incorrect Rainwater Calculation Example: Given the example provided, [3, 0, 2, 4, 0, 3] with operations [[1, 4]], the updated heights would be [3, 1, 3, 5, 1, 3]. Following the provided rainwater trapping algorithm, the computed trapped water does not match the value of 13 as suggested by the tests.", "4, Lack of Clarity in Operations Description: The problem statement ambiguously states that the operations \"increase the height of each segment from index 's' to 'e' (inclusive) by 1 height unit\". This could confuse competitors about whether the operation at index 'e+1' decreases by 1 or remains unchanged. A more explicit explanation with an incremental example could better illustrate the mechanics of elevation operations."]}}
{"task_id": "hard/10", "prompt": "def manage_documents(documents):\n    \"\"\"\n    In a document management system, there are documents with unique identification and revision versions. Your task is to manage these documents effectively using AVL Tree and to find the longest palindromic sequence of document IDs after all insertions are complete.\n\n    Each document is represented by a tuple (document_id, revision).\n    The function should:\n    - Insert new documents into the AVL Tree.\n    - Delete documents from the AVL Tree when a revision supersedes the previous ones.\n    - Return the length of the longest palindromic sequence of the document IDs in the AVL Tree.\n\n    Input:\n    - documents: A list of tuples. Each tuple represents a document as (document_id, revision).\n\n    Output:\n    - Return the length of the longest palindromic sequence of document IDs.\n\n    Example:\n    For documents = [(1, 1), (2, 1), (3, 1), (2, 2), (1, 2), (3, 2)], the longest palindromic sequence of IDs would be [1, 2, 3, 2, 1] which has a length of 5.\n    \"\"\"\n", "canonical_solution": "    class AVLNode:\n        def __init__(self, key):\n            self.left = None\n            self.right = None\n            self.height = 1\n            self.key = key\n        def update_height(self):\n            self.height = max((self.left.height if self.left else 0), (self.right.height if self.right else 0)) + 1\n\n    class AVLTree:\n        def __init__(self):\n            self.root = None\n        def insert(self, key):\n            # Custom insert which handles revisions\n        def delete(self, key):\n            # Custom delete which handles revisions\n\n        def find_longest_palindromic_sequence(self):\n            # Convert tree keys to a list, sequence of document IDs\n            # Apply Manacher's algorithm to find longest palindrome\n\n    // Usage\n    avl_tree = AVLTree()\n    for document_id, revision in documents:\n        avl_tree.insert(document_id, revision)\n    return avl_tree.find_longest_palindromic_sequence()", "test": "def check(candidate):\n    assert candidate([(1, 1), (2, 1), (3, 1), (2, 2), (1, 2), (3, 2)]) == 5\n    assert candidate([(4, 1), (5, 1), (6, 1)]) == 1\n    assert candidate([]) == 0\n    assert candidate([(10, 1), (10, 2), (10, 3), (10, 4)]) == 1\n    assert candidate([(7, 1), (8, 1), (8, 2), (7, 2), (9, 1)]) == 5", "entry_point": "manage_documents", "extra_info": {"cover_story_words": ["document management system", "revision management"], "topics": ["AVL Tree", "Manacher's Algorithm", "Data Structures"], "field": ["Software Engineering"], "cleaned_prompt": "Write a function to manage documents using an AVL Tree for insertion and deletion. After inserting all documents, compute the longest palindromic sequence of document IDs using an efficient algorithm.\n\nInput: List of tuples (document_id, revision). Output: Length of longest palindromic sequence of document IDs.\n\nExample: For documents = [(1, 1), (2, 1), (3, 1), (2, 2), (1, 2), (3, 2)], the longest sequence would be [1, 2, 3, 2, 1] with length 5.", "warnings": ["Solution failed correctness check. reason: failed: expected an indented block (<string>, line 34)", "5, Ambiguity in Problem Requirements: The problem prompt and example suggest handling both document numbers and revision numbers, but the details and method for handling revisions operationally (e.g., version control, how they affect the tree structure, order, etc.) are not specified. This lack of clarity can lead to multiple interpretations and implementations, which is problematic for ensuring consistent solutions among participants.", "4, Misuse of Data Structures: The use of an AVL Tree to track document numbers and then extracting these numbers to find the longest palindromic sequence using Manacher's algorithm seems inefficient and inappropriate. AVL Trees are meant for fast lookups, insertions, and deletions, not for operations on sequential data like finding palindromes, which could be more directly and efficiently handled using other data structures or methods specifically suited for sequence analysis.", "4, Incomplete Solution Template: The canonical solution provided lacks complete implementation details (e.g., the AVLTree _insert, _delete methods and Manacher's algorithm implementation are omitted), which can confuse participants about the expected level of detail and specific AVL and algorithmic knowledge required."]}}
{"task_id": "hard/6", "prompt": "def count_artifacts(grid):\n    \"\"\"\n    Suppose you are in a fairy tale world where there has just been a supernatural storm that has scattered magical artifacts all over a kingdom represented by a 2D grid. Each cell in this grid can either be empty (0) or contain part of a magical artifact (1).\n\n    Magical artifacts can be spread over multiple cells but will always form a linear horizontal or vertical segment. Fortunately, the artifacts remain intact in their segments post-storm.\n\n    Your task is to determine how many distinct artifacts are there in the grid. Each artifact is a continuous line of '1's vertically or horizontally. Connections are not counted diagonally. Furthermore, each '1' in the grid is part of exactly one artifact.\n\n    The grid is guaranteed to have dimensions between 1x1 and 500x500.\n\n    Example:\n    For the grid:\n        [\n            [1, 0, 0, 1, 1],\n            [1, 0, 0, 1, 1],\n            [0, 0, 1, 0, 0],\n            [0, 1, 1, 0, 1]\n        ]\n    The function should return 6, as there are six distinct artifacts:\n        - Two vertical artifacts of length 2 at the first and fourth column.\n        - Two horizontal artifacts of length 2 at the fourth row.\n        - One vertical artifact of length 1 in the third row, third column.\n        - One horizontal artifact of length 1 in the third row.\n    \"\"\"\n", "canonical_solution": "    def count_artifacts(grid):\n        if not grid or not grid[0]:\n            return 0\n\n        rows, cols = len(grid), len(grid[0])\n        visited = [[False] * cols for _ in range(rows)]\n        count = 0\n\n        def dfs(r, c, direction):\n            if direction == 'horizontal':\n                while c < cols and grid[r][c] == 1 and not visited[r][c]:\n                    visited[r][c] = True\n                    c += 1\n            else:  # direction == 'vertical'\n                while r < rows and grid[r][c] == 1 and not visited[r][c]:\n                    visited[r][c] = True\n                    r += 1\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1 and not visited[r][c]:\n                    if c == 0 or grid[r][c-1] == 0:\n                        dfs(r, c, 'horizontal')\n                        count += 1\n                    if r == 0 or grid[r-1][c] == 0:\n                        dfs(r, c, 'vertical')\n                        count += 1\n        return count", "test": "def check(candidate):\n    assert candidate([[1, 0, 0, 1, 1], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 1, 1, 0, 1]]) == 6\n    assert candidate([[1, 1, 0, 1], [1, 1, 0, 1], [0, 0, 1, 1]]) == 3\n    assert candidate([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 5\n    assert candidate([[1]]) == 1\n    assert candidate([[0,0,0,0],[0,0,0,0]]) == 0", "entry_point": "count_artifacts", "extra_info": {"cover_story_words": ["supernatural storm", "fairy tale"], "topics": ["Counting Sort", "Line Sweep"], "field": ["Computer Vision"], "cleaned_prompt": "Write a function that receives a 2D grid, each cell in the grid being either empty (0) or contain part of a magical artifact (1). Artifacts form continuous horizontal or vertical segments of '1's. Your function should count and return the number of distinct magical artifacts in the grid. Artifacts do not connect diagonally and each '1' belongs to exactly one artifact. For example, in a grid [[1, 1, 0], [0, 0, 0], [1, 0, 1]], the count of artifacts would be 3.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Logical flaw in algorithm implementation: The provided canonical solution has a critical logical flaw where it checks cell-by-cell for starting new artifacts both horizontally and vertically without proper conditions to determine the actual start of an artifact. This approach leads to the double-counting of artifacts that can start from intersecting horizontal and vertical lines. This violates the constraint where each '1' in the grid is part of exactly one artifact. The DFS function is incorrectly initialized for every '1' that follows an empty cell or edge cell, regardless of whether it's part of an already counted segment or starting a new unique segment, particularly when such a cell could be reached through horizontal and vertical paths simultaneously."]}}
{"task_id": "hard/3", "prompt": "def frontier_vortex_energy_distribution(vortices, queries):\n    \"\"\"\n    In a fictional Wild West world, energy is distributed through interdimensional vortices arranged in a special kind of Binary Search Tree called the Frontier Vortex Energy Tree (FVET). Each node in this tree represents a vortex and is identified by a unique transaction ID processed through a blockchain network. Each node holds information about its energy level.\n\n    Given the transaction IDs, in the form of BST node keys, and associated energy levels, construct this Binary Search Tree. Once the tree is constructed, your task is to perform a series of energy range queries. An energy range query specifies a lower and upper transaction ID boundary and asks for the total energy within this range.\n\n     Each query is represented as a tuple (low, high), where low and high are the transaction IDs marking the boundary of the query. You need to efficiently calculate the total energy contained in the nodes within this boundary using augmented properties for faster range sum calculations.\n\n    Example:\n    vortices = [(5, 30), (3, 20), (8, 40), (1, 10), (4, 25), (7, 35)]\n    queries = [(1, 4), (3, 7)]\n    - For the range (1, 4), the expected energy sum is 55 (10 from node 1, 20 from node 3, and 25 from node 4).\n    - For the range (3, 7), the expected energy sum is 80 (20 from node 3, 25 from node 4, and 35 from node 7).\n\n    Note:\n    - The BST nodes' keys are unique positive integers that represent transaction IDs.\n    - Nodes' keys and energy levels are given as tuples (key, energy).\n    \"\"\"", "entry_point": "frontier_vortex_energy_distribution", "canonical_solution": "    class TreeNode:\n        def __init__(self, key, energy):\n            self.key = key\n            self.energy = energy\n            self.left = None\n            self.right = None\n            self.subtree_energy_sum = energy  # Augmented property for subtree sum\n\n    def insert_bst(root, key, energy):\n        if not root:\n            return TreeNode(key, energy)\n        elif key < root.key:\n            root.left = insert_bst(root.left, key, energy)\n            root.subtree_energy_sum += energy\n        else:\n            root.right = insert_bst(root.right, key, energy)\n            root.subtree_energy_sum += energy\n        return root\n\n    def sum_range(node, low, high):\n        if not node:\n            return 0\n        if low <= node.key <= high:\n            total_energy = node.energy\n            total_energy += sum_range(node.left, low, high)\n            total_energy += sum_range(node.right, low, high)\n        else:\n            total_energy = 0\n            if node.key > low:\n                total_energy += sum_range(node.left, low, high)\n            if node.key < high:\n                total_energy += sum_range(node.right, low, high)\n        return total_energy\n\n    root = None\n    for key, energy in vortices:\n        root = insert_bst(root, key, energy)\n    results = [sum_range(root, q[0], q[1]) for q in queries]\n    return results", "test": "def check(candidate):\n    # Test case 1\n    vortices = [(5, 30), (3, 20), (8, 40), (1, 10), (4, 25), (7, 35)]\n    queries = [(1, 4), (3, 7)]\n    assert candidate(vortices, queries) == [55, 80]\n    # Test case 2\n    vortices = [(10, 100), (5, 50), (15, 150), (3, 30), (7, 70), ...]", "extra_info": {"cover_story_words": ["energy vortex", "wild west"], "topics": ["Binary Search Tree", "Augmented BST"], "field": ["Blockchain Technology"], "cleaned_prompt": "Given pairs of transaction IDs and energy, construct an augmented Binary Search Tree. For given range queries on transaction IDs, efficiently compute the total energy within each range. Examples clarify the construction and querying processes in the BST, illustrating use of the augmented properties for enhanced performance.", "warnings": ["Only 1 test cases found. Minimum recommended is 5.", "Solution failed correctness check. reason: failed: invalid syntax (<string>, line 18)", "5, Incorrect example explanation: The problem statement contains inconsistencies in the example explanation, particularly how the energy sums are calculated for the provided range queries. The explanation does not match provided data, causing potential misunderstanding and confusion for the solver.", "5, Inefficient algorithm guidance: The recommended approach provided in the canonical solution appears inefficient, especially for large datasets. It uses simple traversal for summing node ranges without leveraging the BST properties effectively or recommending more sophisticated methods that could operate more efficiently, such as self-balancing trees or augmented BSTs.", "4, Unrealistic problem cover story: The narrative involving \"interdimensional vortices\" and \"Frontier Vortex Energy Tree\" in a \"Wild West world\" feels thematically disjointed and could be confusing. This over-complexity in the storyline might detract from the core task, making it harder for participants to focus on the actual algorithmic challenges.", "4, Missing complexity and constraint details: The problem lacks detail on critical constraints such as the number of vortices, number of queries, the range of transaction IDs, and energy levels. This omission hinders the ability to effectively gauge the expected efficiency and difficulty of the problem, complicating both solution planning and testing."]}}
{"task_id": "hard/7", "prompt": "def fairies_schedule_management(cafe_times, fairness_relations):\n    \"\"\"\n    In a cyber cafe famous amongst students, mischievous metaphysical entities - fairies, play around with the cafe's course schedule. This cyber cafe offers special courses on various advanced topics including computer vision which the students need to complete in a specified order based on their complexity.\n\n    However, due to the antics of these fairies, the schedule might now have cycles due to swapped courses. Your task is to determine if all courses can still be completed without any cyclic dependencies after considering the fairies' swaps.\n\n    You're given:\n    - cafe_times: which are tuples (a, b) indicating course 'a' needs to be finished before course 'b' can be started.\n    - fairness_relations: a list of pairs (fa, fb) indicating that the ordering of courses 'fa' and 'fb' have been swapped.\n\n    This involves modifying the graph structure by reversing the direction of the edges specified in the fairness_relations and then checking for cycles using Tarjan's Algorithm.\n\n    Example:\n    If cafe_times = [(1, 2), (2, 3), (3, 4)] and fairness_relations = [(2, 3)], applying the swaps results in the pair: (3, 2), and the graph should be checked for cycles.\n\n    Note:\n    - It's guaranteed that the input lists will not have repeat elements.\n    - Assume all courses are labeled with unique integers starting from 1.\n\n    \"\"\"", "canonical_solution": "    def tarjan(v, adj_list):\n        index = 0\n        stack = []\n        indices = [-1] * (v + 1)\n        lowlink = [0] * (v + 1)\n        result = []\n        on_stack = [False] * (v + 1)\n\n        def strongconnect(node):\n            nonlocal index\n            indices[node] = index\n            lowlink[node] = index\n            index += 1\n            stack.append(node)\n            on_stack[node] = True\n\n            for neighbor in adj_list[node]:\n                if indices[neighbor] == -1:\n                    strongconnect(neighbor)\n                    lowlink[node] = min(lowlink[node], lowlink[neighbor])\n                elif on_stack[neighbor]:\n                    lowlink[node] = min(lowlink[node], indices[neighbor])\n\n            if lowlink[node] == indices[node]:\n                connected_component = []\n                while True:\n                    w = stack.pop()\n                    on_stack[w] = False\n                    connected_component.append(w)\n                    if w == node:\n                        break\n                result.append(connected_component)\n\n        for i in range(1, v + 1):\n            if indices[i] == -1:\n                strongconnect(i)\n        return any(len(c) > 1 for c in result)\n\n    from collections import defaultdict\n    adj_list = defaultdict(list)\n    max_vertex = 0\n    for a, b in cafe_times:\n        adj_list[a].append(b)\n        max_vertex = max(max_vertex, a, b)\n    for fa, fb in fairness_relations:\n        adj_list[fa].remove(fb)\n        adj_list[fb].append(fa)\n\n    return not tarjan(max_vertex, adj_list)", "test": "def check(candidate):\n    # Test cases including the examples from the prompt\n    assert candidate([(1, 2), (2, 3), (3, 4)], [(2, 3)]) == True\n    assert candidate([(1, 2), (2, 3), (3, 1)], []) == False\n    assert candidate([(1, 2), (2, 3), (4, 3)], [(3, 4)]) == True\n    assert candidate([(1, 2), (2, 3), (3, 4)], [(1, 3), (3, 1)]) == False\n    assert candidate([(1, 2), (2, 3), (3, 1)], [(1, 3)]) == False", "entry_point": "fairies_schedule_management", "extra_info": {"cover_story_words": ["cyber cafe", "mischievous fairies"], "topics": ["Course Schedule", "Tarjan's Algorithm"], "field": ["Computer Vision"], "cleaned_prompt": "Given a list of course prerequisites and a list of course swaps due to fairies' mischiefs, determine if the courses can be completed in a valid order using Tarjan's Algorithm to detect cycles.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 20)", "5, Ambiguity in Output: The problem statement does not clearly define the expected output format. The description suggests determining if all courses can still be completed without any cyclic dependencies, but does not specify if the function should return a boolean (True or False) or another type of output indicating the result. This could lead to wrong implementations since programmers might be unclear about what specific output needs to be returned.", "5, Inconsistent Test Case Output Expectations: The provided test cases in the 'test' section appear to expect boolean outputs (True or False) directly contradicting the undefined output format in the prompt. Such inconsistency can confuse contestants about the expected function behavior and implementation specifics.", "5, Incorrect Implementation Example: In the canonical solution provided, there's an attempt to modify an adjacency list by removing edges and adding the reversed edges for fairness_relations. This could potentially throw errors if an edge being reversed does not exist in the original graph. The algorithm could attempt to remove a non-existent edge from the adjacency list, potentially causing runtime errors.", "4, Unhandled Edge Case in Solution: The solution given does not consider the scenario where a fairness relation specifies a swap (fa, fb) for nodes that aren't connected directly, leading to an incorrect removal of an edge. This may result in misrepresentation of the graph's structure, thereby affecting the cycle detection logic."]}}
{"task_id": "hard/4", "prompt": "def mystical_chain_combinations(start, blocks, K):\n    \"\"\"\n    In a mystical jungle combined with fairy tale elements, there's a blockchain that controls magical barriers. The blockchain consists of blocks represented as nodes in a doubly linked list. Each node contains a magic number. In the world of fairy tales, you find some blocks in the form of a doubly linked list starting from the given block 'start'.\n\n    The kingdom's emperor is pondering about the security of their realm. He wants to calculate how many secure blockchain combinations can be generated from the given set of blocks. A combination is called secure if the product of the magic numbers from the selected blocks in a sequence is not divisible by the given integer 'K'.\n\n    Write a function that calculates how many secure combinations of the doubly linked list blocks can be made from a continuous sequence of blocks such that no combination's product of magic numbers is divisible by 'K'. The sequences should be unique (i.e., different starting or ending block).\n\n    Note:\n    - Constraints: List size (1 <= size <= 1000), Magic numbers (1 <= magic number <= 10^9), K (1 <= K <= 10^9).\n    - If 'start' is None or there are not enough blocks to form any sequence, return 0.\n    - Start could be any block and can traverse forward or backwards using the doubly-linked nature.\n    - Assume that each function call will provide enough blocks that can generate at least one valid combination.\n    \"\"\"\n", "entry_point": "mystical_chain_combinations", "canonical_solution": "    def is_magic_product_secure(blocks, K):\n        count_secure = 0\n        n = len(blocks)\n        for start in range(n):\n            product = 1\n            for end in range(start, n):\n                product *= blocks[end]\n                if product % K != 0:\n                    count_secure += 1\n        return count_secure\n\n    # Convert linked list to list\n    numbers = []\n    ptr = start\n    if not ptr:\n        return 0\n    while ptr:\n        numbers.append(ptr.magic)\n        ptr = ptr.next\n\n    return is_magic_product_secure(numbers, K)", "test": "def check(candidate):\n    class Node:\n        def __init__(self, magic, next=None, prev=None):\n            self.magic = magic\n            self.next = next\n            self.prev = prev\n\n    # Creating the doubly linked list from array\n    def create_doubly_linked_list(arr):\n        head = Node(arr[0])\n        current = head\n        if len(arr) == 1:\n            return head\n        for num in arr[1:]:\n            new_node = Node(num)\n            current.next = new_node\n            new_node.prev = current\n            current = new_node\n        return head\n\n    # Test cases\n    blocks1 = create_doubly_linked_list([1, 2, 3, 4])\n    assert candidate(blocks1, 2) == 4\n\n    blocks2 = create_doubly_linked_list([7, 11, 13, 17])\n    assert candidate(blocks2, 5) == 15\n\n    blocks3 = create_doubly_linked_list([2, 4, 6, 8, 10])\n    assert candidate(blocks3, 3) == 0\n\n    blocks4 = create_doubly_linked_list([3, 6, 1, 5])\n    assert candidate(blocks4, 2) == 11\n\n    blocks5 = create_doubly_linked_list([19, 23, 29, 31])\n    assert candidate(blocks5, 7) == 15", "extra_info": {"cover_story_words": ["jungle", "fairy tale"], "topics": ["Doubly-Linked List", "Combinatorics"], "field": ["Blockchain Technology"], "cleaned_prompt": "Write a function 'mystical_chain_combinations' that takes in 'start', a node of a doubly linked list representing a chain of magical blocks, and a number 'K'. The function should return the number of unique, secure combinations of blocks.\n\n    A sequence of blocks is secure if the product of their numbers (magic numbers) is not divisible by 'K'. Every block has a 'magic' number. 'Start' indicates the initial block, and blocks can be accessed forwards and backwards. Return count of all secure sequences.\n\n    Note:\n    - Constraints: List size (1 <= size <= 1000), Magic numbers (1 <= magic number <= 10^9), K (1 <= K <= 10^9).", "warnings": ["Solution failed correctness check. reason: failed: mystical_chain_combinations() missing 1 required positional argument: 'K'", "5, Inconsistent Behavior with Assumptions: The prompt states that \"Assume that each function call will provide enough blocks that can generate at least one valid combination,\" but the canonical solution explicitly handles cases where `start` is `None` or the blockchain is too short, returning `0`. This contradiction might lead to confusion for users as to what scenarios the function should correctly handle.", "4, Unclear Execution with Backward Traversal: Although the prompt mentions the ability to traverse backward due to the doubly-linked nature of the list, the provided solution and further problem details do not specify how backward traversal affects the counting of combinations or its implementation. This omission could leave participants unsure of how to effectively incorporate this functionality into their solutions."]}}
{"task_id": "hard/8", "prompt": "def hot_air_balloon_courtroom_decision(balloon_images, proposals):\n    \"\"\"\n    Imagine we are trying to decide on the design for a new series of hot air balloons to be used in courtrooms as a novelty method to resolve certain types of cases efficiently. Each design proposal for these balloons is based on various characteristics captured in images.\n\n    Your task is to write a function that takes in a list of images of balloon proposals (each image is represented as a 2D matrix of pixels) and a list of proposals (each represented as a dictionary containing an 'id' and an 'area' within an image that likely contains significant design elements).\n\n    The function should rank each proposal by its effectiveness in a courtroom, based on the clarity and informativeness of content within the proposed 'area'. You must use computer vision concepts such as image clarity measurement or key feature extraction to quantitatively measure these attributes.\n\n    For each proposal, if the 'id' does not match any in balloon_images, it should be flagged as 'invalid'.\n\n    For example, if `balloon_images` are [{'id': 1, 'image': [[0, 255], [255, 0]]}], and `proposals` are [{'id': 1, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}], the effectiveness can be computed using statistical variance or other relevant metrics.\n\n    Note:\n    - All input is expected to be valid and well-formed according to the specification.\n    - The 'area' in proposals is specified as a dictionary with 'top_left' (x, y) and 'bottom_right' (x, y) coordinates of the rectangle.\n    \"\"\"", "canonical_solution": "    def extract_area(image, area):\n        x1, y1 = area['top_left']\n        x2, y2 = area['bottom_right']\n        return [row[x1:x2+1] for row in image[y1:y2+1]]\n\n    def calculate_effectiveness(subimage):\n        import numpy as np\n        arr = np.array(subimage)\n        return np.var(arr)\n\n    balloon_dict = {balloon['id']: balloon['image'] for balloon in balloon_images}\n\n    proposal_effectiveness = []\n    for proposal in proposals:\n        if proposal['id'] not in balloon_dict:\n            proposal_effectiveness.append({'id': proposal['id'], 'effectiveness': 'invalid'})\n            continue\n        image = balloon_dict[proposal['id']]\n        area = proposal['area']\n        subimage = extract_area(image, area)\n        effectiveness = calculate_effectiveness(subimage)\n        proposal_effectiveness.append({'id': proposal['id'], 'effectiveness': effectiveness})\n\n    sorted_proposals = sorted(proposal_effectiveness, key=lambda x: x['effectiveness'] if isinstance(x['effectiveness'], float) else float('-inf'), reverse=True)\n    return sorted_proposals", "test": "def check(candidate):\n    assert candidate([\n        {'id': 1, 'image': [[100, 100], [100, 100]]}\n    ], [\n        {'id': 1, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 1, 'effectiveness': 0.0}]\n\n    assert candidate([\n        {'id': 2, 'image': [[255, 0], [0, 255]]},\n        {'id': 3, 'image': [[10, 100], [200, 50]]}\n    ], [\n        {'id': 2, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}},\n        {'id': 3, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 3, 'effectiveness': 5775.0}, {'id': 2, 'effectiveness': 10406.25}]\n\n    assert candidate([\n        {'id': 4, 'image': [[30, 60], [70, 90]]}\n    ], [\n        {'id': 4, 'area': {'top_left': (0, 0), 'bottom_right': (0, 0)}}\n    ]) == [{'id': 4, 'effectiveness': 0.0}]\n\n    assert candidate([\n        {'id': 5, 'image': [[100, 255], [255, 100]]}\n    ], [\n        {'id': 5, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 5, 'effectiveness': 7246.25}]\n\n    assert candidate([\n        {'id': 6, 'image': [[0, 200], [200, 0]]}\n    ], [\n        {'id': 6, 'area': {'top_left': (0, 0), 'bottom_right': (1, 1)}}\n    ]) == [{'id': 6, 'effectiveness': 10000.0}]", "entry_point": "hot_air_balloon_courtroom_decision", "extra_info": {"cover_story_words": ["hot air balloon", "courtroom"], "topics": ["Subsets", "Quickselect"], "field": ["Computer Vision"], "cleaned_prompt": "Write a function that processes a list of images of balloon proposals (each image as a 2D pixel matrix) and proposals (each as a dictionary with 'id' and rectangle 'area'). Rank the proposals by courtroom effectiveness based on the clarity and informativeness of each 'area', using quantitative computer vision techniques. Flag proposals with non-matching 'id' as 'invalid'.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 16)", "5, Impractical scenario: The premise of using hot air balloon designs in courtrooms for case resolution is highly impractical and does not relate closely enough to real-world applications or typical problem-solving scenarios expected in coding competitions. This could confuse participants and detract from the problem's educational value.", "4, Misalignment with noted topics: The problem statement includes \"Subsets\" and \"Quickselect\" as topics, but neither of these seems directly relevant to the primary task, which focuses on image processing and basic computational assessment of images. This may mislead participants regarding the skills and knowledge they should apply."]}}
