{"task_id": "hard/5", "entry_point": "classify_plant_species", "prompt": "def classify_plant_species(descriptions):\n    \"\"\"\n    In the Greenthumb Gorge, scientists have documented several unique plant species. Each plant species has been described textually, revealing attributes such as color, size, and leaf shape. Your task is to develop a function that classifies these plants into specific categories based on their textual descriptions.\n\n    Your function should take a list of descriptions and return a list of predicted categories for each description. Implement text processing, feature extraction, and machine learning classification algorithms to classify each plant properly.\n\n    Example:\n        Input:  ['Small plant with needle-like leaves and red flowers', 'Large tree with broad leaves and round fruits']\n        Output: ['Cactus', 'Fruit Tree']\n\n    Note:\n    - The categories you need to classify are 'Cactus', 'Fruit Tree', 'Palm Tree', 'Sunflower', 'Vine', 'Carnivorous Plant', 'Rose', 'Oak Tree', 'Bush'.\n    - Use any necessary NLP techniques and Machine Learning models (e.g., SVM, RandomForest).\n    \"\"\"", "canonical_solution": "        from sklearn.feature_extraction.text import TfidfVectorizer\n        from sklearn.preprocessing import LabelEncoder\n        from sklearn.svm import SVC\n\n        # Training data and labels (example, real dataset should be provided or accessed for actual usage)\n        descriptions = ['Small plant with needle-like leaves and red flowers', 'Large tree with broad leaves and round fruits']\n        labels = ['Cactus', 'Fruit Tree']\n\n        vectorizer = TfidfVectorizer()\n        X = vectorizer.fit_transform(descriptions)\n\n        label_encoder = LabelEncoder()\n        y = label_encoder.fit_transform(labels)\n\n        model = SVC()\n        model.fit(X, y)\n\n        def classify_plant_species(descriptions):\n            transformed_descriptions = vectorizer.transform(descriptions)\n            predictions = model.predict(transformed_descriptions)\n            return label_encoder.inverse_transform(predictions)", "test": "def check(candidate):\n    assert candidate(['Small cactus with spiky silhouette','Tall palm tree with coconuts']) == ['Cactus', 'Palm Tree']\n    assert candidate(['Flowering plant with large yellow petals', 'Vine with round grapes']) == ['Sunflower', 'Vine']\n    assert candidate(['Carnivorous plant with sharp trap', 'Rose with thorns and red petals']) == ['Carnivorous Plant', 'Rose']\n    assert candidate(['Oak tree with hard bark and acorns', 'Small prickly bush with blueberries']) == ['Oak Tree', 'Bush']\n    assert candidate([]) == []", "extra_info": {"cover_story_words": ["Greenthumb Gorge", "plant species"], "topics": ["Machine Learning", "Natural Language Processing", "Text Classification"], "field": ["Computer Science"], "cleaned_prompt": "Develop a function to classify plant species based on textual descriptions using text processing and machine learning. Example input: ['Small plant with needle-like leaves and red flowers'] outputs 'Cactus'. Define specific categories such as 'Cactus', 'Fruit Tree', etc., for classification.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 14)", "5, Missing Data: The problem description suggests building a machine learning model to classify plant species from descriptions but does not provide a dataset for training the model. It only provides a minimal example, which is insufficient for training a robust classifier.", "4, Training in Function: The canonical solution indicates that feature extraction and model training occurs within the function. This is a flawed practice as training should only happen once, and the trained model should be callable or utilized for predictions without retraining at each function call.", "5, Unclear Problem Scope: The problem assumes the implementation of advanced text processing and machine learning algorithms without clear constraints or requirements on the algorithm's performance, computational efficiency, or the handling of ambiguous or unseen descriptions."]}}
{"task_id": "hard/4", "entry_point": "decode_message", "prompt": "def decode_message(messages, model):\n    \"\"\"\n    Imagine a scenario where messages are transmitted but are scrambled so that the words are out of order but the message content is intact. Your task is to reconstruct the original message using natural language processing techniques.\n\n    Each message received is a string of words separated by spaces. Words can contain letters and occasionally punctuation, like commas or periods. The capitalization of the words may vary.\n\n    Write a function that takes a list of scrambled messages and an NLP model, and returns a list of messages with the words in the most likely original order. Use the provided NLP model to determine the optimal order of words based on language understanding.\n\n    Input details:\n    - The messages list will contain between 0 and 10 scrambled messages.\n    - Each message will contain between 1 and 10 words.\n\n    Example:\n    - messages: ['universe is mysterious The', 'very deck observatory, the on is cold The']\n    - model: a preloaded NLP model you can utilize to process text\n    Output:\n    - ['The universe is mysterious', 'The deck on the observatory is very cold']\n    \"\"\"\n", "canonical_solution": "    def decode_message(messages, model):\n        decoded_messages = []\n        for message in messages:\n            words = message.split()\n            permutations = itertools.permutations(words)\n            best_sentence = None\n            max_prob = 0\n            for perm in permutations:\n                sentence = ' '.join(perm)\n                doc = model(sentence)\n                prob = sum([tok.prob for tok in doc])\n                if prob > max_prob:\n                    max_prob = prob\n                    best_sentence = sentence\n            decoded_messages.append(best_sentence)\n        return decoded_messages", "test": "def check(candidate):\n    import spacy\n    nlp = spacy.load('en_core_web_sm')\n    assert candidate(['universe is mysterious The'], nlp) == ['The universe is mysterious']\n    assert candidate(['The scrambled this, is message'], nlp) == ['This message is scrambled,']\n    assert candidate(['fog heavy, through the communicate We'], nlp) == ['We communicate through the heavy fog']\n    assert candidate(['stars curious observe the to continue We'], nlp) == ['We continue to observe the curious stars']\n    assert candidate([], nlp) == []", "extra_info": {"cover_story_words": ["scrambled messages", "word order reconstruction"], "topics": ["Natural Language Processing", "Language Modeling", "Permutations"], "field": ["Computer Science", "Language Processing"], "cleaned_prompt": "Write a function that takes a list of scrambled messages and an NLP model, and returns the messages with words in their likely original order. The NLP model helps to understand the most probable construction of sentences. Each message will have words that might be out of order and is separated by spaces.\nExample:\n- Input: ['universe is mysterious The'], NLP model\n  Output: ['The universe is mysterious']", "warnings": ["Solution failed correctness check. reason: failed: No module named 'spacy'", "4, Combinatorial Explosion: The provided canonical solution suggests generating all permutations of words in the message to determine the best order. Given that each message can contain up to 10 words, this would result in up to 3,628,800 permutations (10 factorial) per message. This approach is computationally infeasible for larger input sizes, making the solution impractical for real-world applications, especially with the upper message limit of 10.", "5, Incomplete Model Use Explanation: The problem statement lacks detailed information on how the given NLP model should be used to evaluate the probability of the correctness of each permutation of the words. This lack of detail could lead to different interpretations and implementations, causing inconsistent results and difficulties in understanding and using the provided NLP model correctly.", "4, Testing Limitations: The test cases provided assume that there is exactly one correct order for the scrambled messages, which contradicts the acknowledgment of multiple plausible outputs stated in the problem. This could lead to incorrect testing and validation of the candidate's solution, potentially causing confusion and inaccuracies in the assessment process."]}}
{"task_id": "hard/3", "prompt": "def decrypt_message(cipher_text, key):\n    \"\"\"\n    As a secret agent, you've intercepted a string of cipher text transmitted from the sorcerer's tower. This cipher text has been encoded using a custom cyclic key encryption based on Caesar Cipher but with a repeating sequence key.\n\n    Your job is to decrypt it using the known key which consists of a list of integer shifts. Each integer in the list shifts a corresponding character in the cipher text back by that many places in the alphabet.\n\n    The key repeats if the cipher text is longer than the key itself. If the text includes any non-alphabetic characters, they should be left untouched.\n\n    Given the encrypted string 'cipher_text' and a list of integers 'key' representing the cyclic shifts, return the decrypted message as a string.\n\n    Example:\n    If the input is cipher_text = \"Vdqdqhvflv\" and key = [3, 1, 4], the output should be \"Sasquatch\" since applying the shifts -3, -1, -4 cyclically to each character in 'Vdqdqhvflv' results in 'Sasquatch'.\n\n    Note:\n    - Non-alphabet characters must remain unchanged in their position.\n    - The decryption preserves the case of the input to handle both uppercase and lowercase letters correctly.\n    - The function should handle empty strings smoothly.\n    \"\"\"", "canonical_solution": "    def decrypt_character(c, shift):\n        if c.isalpha():\n            start = ord('a') if c.islower() else ord('A')\n            return chr((ord(c) - start - shift) % 26 + start)\n        else:\n            return c\n\n    result = ''\n    key_length = len(key)\n    for index, character in enumerate(cipher_text):\n        shift = key[index % key_length]\n        result += decrypt_character(character, shift)\n    return result", "test": "def check(candidate):\n    assert candidate(\"Vdqdqhvflv\", [3, 1, 4]) == \"Sasquatch\"\n    assert candidate(\"\", [1, 2, 3]) == \"\"\n    assert candidate(\"Hello, World!\", [1, 0, 0]) == \"Gdkkn, World!\"\n    assert candidate(\"AbC\", [1, -1, 1]) == \"ZaA\"\n    assert candidate(\"Complex123\", [3, -3, 5, -5]) == \"Zljmgdy123\"", "entry_point": "decrypt_message", "extra_info": {"cover_story_words": ["secret agent", "sorcerer's tower"], "topics": [], "field": ["Cybersecurity"], "cleaned_prompt": "Write a function that takes a string 'cipher_text' and a list of integers 'key' which represents cyclic shifts to decrypt a custom Caesar Cipher encrypted text. The key repeats for longer texts. Non-alphabetic characters remain untouched. The decryption preserves the case of incoming characters. For example, using cipher_text = \"Vdqdqhvflv\" and key = [3, 1, 4], the function should return \"Sasquatch\".\nGiven this prompt, ensure the problem description, test cases, and canonical solution are consistent regarding case sensitivity.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 18)", "4, Inconsistent Case Sensitivity Instruction: The problem statement mentions decryption should treat uppercase and lowercase alphabet characters equivalently, but the implementation provided in canonical solution, and expected outputs in tests, evidently maintain case sensitivity. This could cause uncertainty on how input case should be managed and whether or not case normalization is required before decryption.", "5, Confusing Problem Description: The description indicates treating 'A' and 'a' as equivalent which contradicts the test cases and provided solutions that maintain distinct uppercase and lowercase characters in the output. This inconsistency introduces significant confusion on operational expectations and result format in the decryption process."]}}
{"task_id": "hard/7", "entry_point": "decrypt_pirate_message", "prompt": "def decrypt_pirate_message(encoded_message, key):\n    \"\"\"\n    In a tale of high seas adventure, a secret agent intercepts a message from pirates that is encoded using a sophisticated encryption method. This method comprises two layers. First, each alphabetic character is shifted using a Caesar Cipher where the shift amount is the position in the alphabet (i.e., 'a' and 'A' are shifted by 1, 'b' and 'B' by 2, etc.). Second, for both alphabetic and non-alphabetic characters, a XOR operation is applied using the ASCII values of the characters and a repeating key pattern.\n\n    Your task is to decrypt this intercepted message given the encoded_message and a key. Assume non-alphabetic characters are not shifted in the Caesar Cipher but are still processed in the XOR operation.\n\n    Example inputs and outputs:\n    - If the encoded message is '@EPPCQ' (where '@' remains '@' after Caesar since it's non-alphabetic) and the key is 'abc', the output after full decryption should be 'hello'. In this case, the shifting only applies to letters.\n\n    \"\"\"\n", "canonical_solution": "    def decrypt_pirate_message(encoded_message, key):\n        # First decode using Caesar Cipher\n        def shift(char, amount):\n            if char.isalpha():\n                base = ord('a') if char.islower() else ord('A')\n                return chr((ord(char) - base - amount + 26) % 26 + base)\n            return char\n\n        # Shift each letter by its position\n        first_level_decoded = ''.join(shift(char, i + 1 if char.lower() >= 'a' and char.lower() <= 'z' else 0) for i, char in enumerate(encoded_message))\n\n        # Now apply XOR with the key\n        key_extended = (key * ((len(first_level_decoded) // len(key)) + 1))[:len(first_level_decoded)]\n        decoded_message = ''.join(chr(ord(char) ^ ord(key_char)) for char, key_char in zip(first_level_decoded, key_extended))\n\n        return decoded_message\n", "test": "def check(candidate):\n    assert candidate('@EPPCQ', 'abc') == 'hello'\n    assert candidate('QTVPW', 'key') == 'start'\n    assert candidate(']^[YcVR`SVR', 'abc') == 'encryption'\n    assert candidate('BBB', 'b') == 'aaa'\n    assert candidate('\\x7f\\x90\\x91', 'key') == 'abc',\n", "extra_info": {"cover_story_words": ["pirates", "secret agent"], "topics": [], "field": ["Cybersecurity"], "cleaned_prompt": "def decrypt_pirate_message(encoded_message, key):\n    \"\"\"\n    Decrypt an encoded message following these steps:\n    - Use a Caesar Cipher that only shifts alphabetic characters backward by their position in the alphabet.\n    - Apply a XOR operation on the ASCII values of all characters (including non-alphabetic ones) with those of a repeating key to decrypt the message.\n\n    Example:\n    - For encoded_message='@EPPCQ' and key='abc', the decrypted result should be 'hello'.\n    \"\"\"\n", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 33)", "5, Logical Inconsistency: The description implies that characters are shifted backward only for the Caesar Cipher based on their position (e.g., 'a' by 1), which contradicts typical Caesar Cipher mechanics where all letters are shifted by a uniform value. Furthermore, the example '@EPPCQ' when decoded under these rules inexplicably decrypts to 'hello' based on the approach described which seems either incorrect or misleading due to the unclear shifting backward mechanism.", "4, XOR Clarification Missing: The description is insufficiently clear on how the key is used in the XOR operation. The prompt should specify if the key needs to undergo transformation or extension to match the length of the message or if the key should be used directly as is, particularly as the solution logic extends the key."]}}
{"task_id": "hard/6", "entry_point": "find_treasure_path", "prompt": "def find_treasure_path(dna_sequences, paths):\n    \"\"\"\n    In a mythical world filled with mountains and an enchanted forest, treasure is hidden and protected by the unique sequence of Runic DNA that governs the growth of the forest.\n    Each mountain pass has a unique DNA sequence stamped into its stone. The treasure can only be reached if one can find a mountain pass whose DNA sequence is a subsequence of the Enchanted Forest's DNA.\n\n    You are given a list of DNA sequences from various mountain passes (`paths`) and the DNA of the enchanted forest (`dna_sequences`), a string.\n    Write a function that takes the DNA of the enchanted forest and a list of DNA sequences from the mountain passes.\n    The function should return the index of the mountain pass DNA in the list that is a subsequence of the Enchanted Forest's DNA, if such a pass exists, or -1 if no such path can be found.\n\n    A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\n    Example:\n    find_treasure_path('ACGTACGTACGT', ['CGT', 'GTAG', 'TAC']) should return 2 because 'TAC' is a subsequence of 'ACGTACGTACGT' while none of the others are.\n    find_treasure_path('GATTACA', ['TAG', 'GGG', 'ACA']) should return 2 because 'ACA' is a subsequence of 'GATTACA'.\n    find_treasure_path('', ['TAG', 'GGG', 'ACA']) should return -1 for an empty 'dna_sequences'.\n    find_treasure_path('GATTACA', []) should return -1 when 'paths' list is empty.\n    find_treasure_path('AAAA', ['AAAA', 'AAAA']) should return 0 when all characters in 'paths' are the same as 'dna_sequences'.\n\n    Note:\n    The given 'dna_sequences' and the 'paths' are all in uppercase and contain only the characters 'A', 'C', 'G', and 'T'.\n    \"\"\"\n", "canonical_solution": "    def is_subsequence(dna, subseq):\n        it = iter(dna)\n        return all(c in it for c in subseq)\n    for index, path in enumerate(paths):\n        if is_subsequence(dna_sequences, path):\n            return index\n    return -1", "test": "def check(candidate):\n    assert candidate('ACGTACGTACGT', ['CGT', 'GTAG', 'TAC']) == 2\n    assert candidate('GATTACA', ['TAG', 'GGG', 'ACA']) == 2\n    assert candidate('AGGTCCAGTACG', ['TTA', 'AGGTCC', 'CAGT']) == 1\n    assert candidate('CCCCCCCC', ['AA', 'CC', 'TT']) == 1\n    assert candidate('AAAA', ['A', 'AA', 'AAA', 'AAAA', 'AAAAA']) == 3\n    assert candidate('TGGATCCGA', ['GGG', 'ATC', 'GGAT']) == 2\n    assert candidate('', ['TAG', 'GGG', 'ACA']) == -1\n    assert candidate('GATTACA', []) == -1\n    assert candidate('AAAA', ['AAAA', 'AAAA']) == 0", "extra_info": {"cover_story_words": ["mountains", "enchanted forest"], "topics": [], "field": ["Bioinformatics"], "cleaned_prompt": "Write a function `find_treasure_path(dna_sequences, paths)` where `dna_sequences` is a string representing the DNA of the enchanted forest and `paths` is a list of strings representing DNA sequences from various mountain passes.\nThe function should return the index of the mountain path whose DNA sequence is a subsequence of the enchanted forest's DNA; if no such sequence exists, return -1.\nExamples:\nfind_treasure_path('ACGTACGTACGT', ['CGT', 'GTAG', 'TAC']) should return 2.\nfind_treasure_path('GATTACA', ['TAG', 'GGG', 'ACA']) should return 2.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Ambiguous_parameter_ordering: The problem description ambiguously describes that the function takes \"the DNA of the enchanted forest and a list of DNA sequences from the mountain passes,\" without explicitly stating the order of these parameters. It needs to clearly specify the sequence in which parameters should be passed to the function.", "4, Potential_edge_case_omission: The problem's examples and explanations do not adequately cover or clarify behavior when 'dna_sequences' contains repeating patterns or overlapping potential matches within 'paths'. This could lead to uncertainties in expected function behavior during implementation."]}}
{"task_id": "hard/9", "prompt": "def spell_similarity(spell1, spell2):\n    \"\"\"\n    In a mystical wizard school, spells consist of sequences of magic glyphs represented by characters. Each spell has a unique sequence of glyphs.\n    Your task is to determine the similarity between two spells based on their magic glyph sequences using the Needleman-Wunsch algorithm (a bioinformatics algorithm commonly used for sequence alignment).\n\n    The similarity is calculated based on the following clearly defined scoring:\n    - Match: +2 (when two corresponding glyphs match)\n    - Mismatch: -1 (when two corresponding glyphs are different)\n    - Gap: -2 (when a glyph is aligned with a gap in the other spell)\n\n    Explicitly handle edge cases such as when either or both of the spells are empty. The score for aligning two empty spells is 0.\n\n    For example, if spell1 is 'ABC' and spell2 is 'AEC', the maximum alignment score (similarity) would be 2 (A matches A, B to gap, C matches C: +2 -2 +2).\n    Another example is for spell1 'AB' and spell2 'A', the maximum alignment score would be 0 (A matches A, B to gap: +2 -2).\n\n    Parameters:\n        spell1 (str): A string representing the glyph sequence of the first spell.\n        spell2 (str): A string representing the glyph sequence of the second spell.\n\n    Returns:\n        int: The similarity score between the two spells.\n    \"\"\"\n", "canonical_solution": "    def spell_similarity(spell1, spell2):\n        import numpy as np\n        def score(a, b):\n            if a == b:\n                return 2  # Match score\n            elif a == '-' or b == '-':\n                return -2  # Gap score\n            else:\n                return -1  # Mismatch score\n        \n        n, m = len(spell1), len(spell2)\n        dp = np.zeros((n + 1, m + 1), dtype=int)\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i-1][0] - 2  # Initializing gaps\n        for j in range(1, m + 1):\n            dp[0][j] = dp[0][j-1] - 2  # Initializing gaps\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                match = dp[i-1][j-1] + score(spell1[i-1], spell2[j-1])\n                delete = dp[i-1][j] - 2\n                insert = dp[i][j-1] - 2\n                dp[i][j] = max(match, delete, insert)\n        return dp[n][m]", "test": "def check(candidate):\n    assert candidate('ABC', 'AEC') == 2\n    assert candidate('AB', 'A') == 0\n    assert candidate('ABC', 'ABC') == 6\n    assert candidate('ABC', 'DEF') == -3\n    assert candidate('A', 'B') == -3\n    assert candidate('HELLO', 'HELLO') == 10\n    assert candidate('', '') == 0\n    assert candidate('WIZARD', 'WZRD') == 4\n    assert candidate('MAGIC', 'MAGICAL') == 2", "entry_point": "spell_similarity", "extra_info": {"cleaned_prompt": "Define a function that calculates the similarity score between two strings (spells) using the Needleman-Wunsch algorithm with match score +2, mismatch score -1, and gap score -2, including explicit handling for edge cases where either or both of the spells might be empty.\n\nExamples:\n- 'ABC' vs 'AEC' should return a similarity score of 2.\n- 'AB' vs 'A' should return a similarity score of 0.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Clarity in Problem Statement: The problem statement mentions the use of the Needleman-Wunsch algorithm, which is generally understood but does not provide the exact implementation details required for proper scoring and alignment, such as initialization of boundary conditions in the dynamic programming table.", "4, Ambiguity in Edge Cases: The statement provides initial guidance for edge cases, such as handling empty strings, but does not clearly define behavior for sequences of massive length difference, which may lead to inefficient performance without proper optimization techniques being highlighted."], "cover_story_words": ["wizard school", "magic glyphs"], "topics": [], "field": ["Bioinformatics"]}}
{"task_id": "hard/1", "prompt": "def analyze_artifacts(artifact_signals):\n    \"\"\"\n    Imagine you are at an archaeological dig site and have discovered a number of ancient artifacts. Each artifact emits a unique signal pattern that can be detected by your IoT devices deployed around the site. Your goal is to analyze these signal patterns to determine which of them might indicate the presence of a portal to an ancient civilization.\n\n    Each signal pattern is represented as a list of integers, where each integer represents the strength of the signal detected at a certain time. A portal signal is defined by the following criteria:\n    1. The signal strength must strictly alternate between increasing and decreasing over any eight consecutive measurements.\n    2. The sum of all measurements in the signal pattern must be a prime number.\n\n    Write a function that takes a list of signal patterns (where each signal pattern is a list of integers) and returns the number of signal patterns that match the criteria for a 'portal' signal. Only patterns with eight measurements or more can be considered as potential portal signals.\n\n    Example input: [[5, 10, 5, 10, 5, 10, 5, 10], [3, 6, 3, 6, 3, 6, 6], [5, 10, 15]]\n    Example output: 1 # Because the first pattern matches all criteria for a portal signal\n    \"\"\"\n", "canonical_solution": "    from math import isqrt\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def is_alternating(sequence):\n        if len(sequence) < 8:\n            return False\n        for i in range(len(sequence) - 7):\n            if not all((sequence[j] < sequence[j+1] > sequence[j+2] < sequence[j+3]) for j in range(i, i+7, 3)):\n                return False\n        return True\n\n    count = 0\n    for pattern in artifact_signals:\n        if len(pattern) >= 8 and sum(pattern) and is_prime(sum(pattern)) and is_alternating(pattern):\n            count += 1\n    return count", "test": "def check(candidate):\n    assert candidate([[5, 10, 5, 10, 5, 10, 5, 10], [3, 6, 3, 6, 3, 6, 6], [5, 10, 15]]) == 1\n    assert candidate([[2, 3], [4, 5, 4, 5, 4, 5, 4, 5], [1, 2, 1, 2, 1, 2, 1], [3, 1, 3, 1, 3, 1]]) == 0\n    assert candidate([[10, 20, 10, 20, 10, 20, 10, 20], [1, 2, 3, 4, 5, 6, 7, 8], [5, 10, 5, 10, 5, 10, 5]]) == 1\n    assert candidate([]) == 0\n    assert candidate([[3, 2, 3, 2, 3, 2, 3, 2], [3, 2, 3, 2, 3, 2, 3], [7, 14, 7, 14, 7, 14, 7, 12], [7, 14, 7, 14, 7, 14, 11, 14]]) == 2", "entry_point": "analyze_artifacts", "extra_info": {"cover_story_words": ["archaeological dig", "portal"], "topics": [], "field": ["Internet of Things (IoT)"], "cleaned_prompt": "def analyze_artifacts(artifact_signals):\n    Each signal pattern is a list of integers representing signal strength over time. A portal signal alternates strictly increasing and decreasing strength over any eight consecutive measurements and the sum of all measurements is a prime number. Only consider patterns with eight measurements or more. Return the number of 'portal' signal patterns.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Logical Flaw in Signal Checking: The provided method 'is_alternating' in the canonical solution checks if the signal alternates strictly between increasing and decreasing over at least eight consecutive measurements incorrectly. It assumes a fixed pattern ([j] < [j+1] > [j+2] < [j+3]) repeatedly, which is not required by the problem statement that indicates any alternating pattern over any eight consecutive measurements is valid. Consequently, this prevents valid alternating sequences that do not match this fixed pattern from being recognized, which leads to incorrect results.", "4, Inconsistent Definition: The problem statement and the canonical solution provide different requirements regarding the sequence length for identification of a 'portal' signal. The statement mentions that \"Only patterns with eight measurements or more can be considered\", yet the check of 'is_alternating' is applied using a looping window without direct reference to ensure each assessment involves all measures of sequences of exactly eight only or at least eight under same conditions; it merely checks from the first position without looping over possible sequences of eight within a longer list."]}}
{"task_id": "hard/2", "prompt": "def assign_superpower(blocks):\n    \"\"\"\n    Imagine a world populated by superheroes and sentient rocks. In this world, a blockchain-like system exists where each block represents a sentient rock and its attributes. Superheroes are assigned to protect the sentient rocks based on the attributes stored in these blocks.\n\n    Each block in the blockchain is a dictionary that includes the following keys:\n    - id: a unique identifier for the block\n    - timestamp: a timestamp when the block was created\n    - data: a dictionary that includes attributes of the sentient rock\n    - previous_hash: a string representing the hash of the previous block\n\n    You are given a list of such blocks. The blockchain system needs a function that, based on the attributes of each sentient rock, assigns a specific superpower to protect it. Superpowers are assigned as follows:\n    - If 'size' is greater than 100, 'strength' superpower is assigned.\n    - If 'intelligence' level is higher than 70, 'mind-control' superpower is assigned.\n    - If 'age' is less than 10 years, 'speed' superpower is assigned.\n\n    If a sentient rock qualifies for multiple criteria, all applicable superpowers are assigned in a list.\n\n    Your task is to write a function that accepts a list of blocks and returns a dictionary mapping each block's id to a list of assigned superpowers. Return an empty list for blocks where no criteria matches.\n\n    Example input: \n    [{'id': 'rock1', 'timestamp': '2021-09-11T10:09:08Z', 'data': {'size': 50, 'intelligence': 80, 'age': 5}, 'previous_hash': 'xxx'},\n     {'id': 'rock2', 'timestamp': '2022-01-01T00:00:00Z', 'data': {'size': 150, 'intelligence': 60, 'age': 20}, 'previous_hash': 'yyy'}]\n\n    Example output: \n    {'rock1': ['mind-control', 'speed'], 'rock2': ['strength']}\n    \"\"\"\n", "canonical_solution": "    def assign_superpower(blocks):\n        result = {}\n        for block in blocks:\n            powers = []\n            data = block['data']\n            if data['size'] > 100:\n                powers.append('strength')\n            if data['intelligence'] > 70:\n                powers.append('mind-control')\n            if data['age'] < 10:\n                powers.append('speed')\n            result[block['id']] = powers\n        return result\n", "test": "def check(candidate):\n    blocks = [\n        {'id': 'rock1', 'timestamp': '2021-09-11T10:09:08Z', 'data': {'size': 50, 'intelligence': 80, 'age': 5}, 'previous_hash': 'xxx'},\n        {'id': 'rock2', 'timestamp': '2022-01-01T00:00:00Z', 'data': {'size': 150, 'intelligence': 60, 'age': 20}, 'previous_hash': 'yyy'},\n        {'id': 'rock3', 'timestamp': '2023-03-15T15:15:15Z', 'data': {'size': 120, 'intelligence': 90, 'age': 9}, 'previous_hash': 'zzz'},\n        {'id': 'rock4', 'timestamp': '2024-04-20T20:20:20Z', 'data': {'size': 90, 'intelligence': 50, 'age': 11}, 'previous_hash': 'aaa'},\n        {'id': 'rock5', 'timestamp': '2025-05-30T30:30:30Z', 'data': {'size': 40, 'intelligence': 60, 'age': 30}, 'previous_hash': 'bbb'}\n    ]\n    expected = {\n        'rock1': ['mind-control', 'speed'],\n        'rock2': ['strength'],\n        'rock3': ['strength', 'mind-control', 'speed'],\n        'rock4': [],\n        'rock5': []\n    }\n    assert candidate(blocks) == expected\n\n    empty_blocks = []\n    assert candidate(empty_blocks) == {}\n", "entry_point": "assign_superpower", "extra_info": {"cover_story_words": ["superheroes", "sentient rocks", "blockchain"], "topics": ["data structures", "blockchain fundamentals", "logical decision making"], "field": ["Blockchain Technology"], "cleaned_prompt": "def assign_superpower(blocks):\n    \"\"\"\n    The function assigns superpowers based on attributes like 'size', 'intelligence', and 'age'.\n    - 'strength' for size > 100.\n    - 'mind-control' for intelligence > 70.\n    - 'speed' for age < 10.\n\n    It returns a dictionary mapping block ids to a list of applicable superpowers, or an empty list if no criteria are met.\n\n    Example input: \n    [{'id': 'rock1', 'timestamp': '2021-09-11T10:09:08Z', 'data': {'size': 50, 'intelligence': 80, 'age': 5}, 'previous_hash': 'xxx'}, {'id': 'rock2', 'timestamp': '2022-01-01T00:00:00Z', 'data': {'size': 150, 'intelligence': 60, 'age': 20}, 'previous_hash': 'yyy'}]\n\n    Example output: \n    {'rock1': ['mind-control', 'speed'], 'rock2': ['strength']}\n    \"\"\"\n", "warnings": ["Only 2 test cases found. Minimum recommended is 5.", "Solution failed correctness check. reason: failed: ", "5, Unrealistic Timestamp: The problem provides a timestamp '2025-05-30T30:30:30Z' for a 'block' which contains an invalid time format as there is no 30th hour or a 30th minute beyond the normal bounds of time representation.", "5, Test Case Error: The test case in the provided `check` function assumes a date string format that includes an invalid date and time such as '2025-05-30T30:30:30Z'. This incorrect timestamp could potentially lead to errors or exceptions when running the test if the system attempts to parse it as a real datetime."]}}
{"task_id": "hard/8", "entry_point": "plant_portal_classifier", "prompt": "def plant_portal_classifier(species_data, test_data, k):\n    \"\"\"\n    Imagine a fictional world where portals to various dimensions exist, which have distinct characteristics based on the flora (plants) in them. Each portal can be identified based on the plant species it contains. \n\n    Your task is to develop a machine learning classifier that predicts the portal based on characteristics of plants observed. For instance, a particular portal might have taller plants, another might have plants with wider leaves, etc.\n\n    Each entry in species_data is a dictionary with the following structure:\n    {\n        'portal_id': int,\n        'features': [float]\n    }\n\n    test_data is a list of features where each feature list needs to be classified into one of the portal ids. The value of k determines the number of nearest neighbors to consider for classification.\n\n    Implement a k-Nearest Neighbours classifier from scratch to classify test data based on the provided training data (species_data).\n\n    Your implementation should handle:\n    - Calculation of Euclidean distance between feature vectors.\n    - Determination of k-nearest vectors.\n    - Majority vote mechanism for classification based on the nearest vectors' portal ids.\n\n    Example:\n    species_data = [\n        {'portal_id': 1, 'features': [10, 0.5, 0.2]},\n        {'portal_id': 2, 'features': [20, 0.3, 0.1]},\n        {'portal_id': 1, 'features': [11, 0.4, 0.2]},\n        {'portal_id': 2, 'features': [19, 0.2, 0.1]}\n    ]\n    test_data = [[10, 0.5, 0.3], [20, 0.3, 0.2]]\n    k = 3\n    Output should be: [1, 2]\n    \"\"\"\n", "canonical_solution": "    def euclidean_distance(a, b):\n        return sum((x - y) ** 2 for x, y in zip(a, b)) ** 0.5\n\n    def k_nearest(species_data, features, k):\n        distances = [(euclidean_distance(entry['features'], features), entry['portal_id']) for entry in species_data]\n        distances.sort()\n        nearest = [portal_id for _, portal_id in distances[:k]]\n        return max(set(nearest), key=nearest.count)\n\n    result = []\n    for features in test_data:\n        portal_id = k_nearest(species_data, features, k)\n        result.append(portal_id)\n    return result", "test": "def check(candidate):\n    species_data1 = [\n        {'portal_id': 1, 'features': [10, 0.5, 0.2]},\n        {'portal_id': 2, 'features': [20, 0.3, 0.1]},\n        {'portal_id': 1, 'features': [11, 0.4, 0.2]},\n        {'portal_id': 2, 'features': [19, 0.2, 0.1]}\n    ]\n    test_data1 = [[10, 0.5, 0.3], [20, 0.3, 0.2]]\n    assert candidate(species_data1, test_data1, 3) == [1, 2]\n\n    species_data2 = [\n        {'portal_id': 1, 'features': [10, 0.5, 0.2]}\n    ]\n    test_data2 = [[10, 0.5, 0.2]]\n    assert candidate(species_data2, test_data2, 1) == [1]\n\n    species_data3 = [\n        {'portal_id': 1, 'features': [2, 0.5, 0.2]},\n        {'portal_id': 2, 'features': [5, 0.3, 0.1]}\n    ]\n    test_data3 = [[7, 0.6, 0.3]]\n    assert candidate(species_data3, test_data3, 2) == [2]\n\n    species_data4 = [\n        {'portal_id': 1, 'features': [120, 0.5, 0.2]},\n        {'portal_id': 2, 'features': [220, 0.3, 0.1]},\n        {'portal_id': 1, 'features': [119, 0.4, 0.2]},\n        {'portal_id': 2, 'features': [215, 0.25, 0.15]}\n    ]\n    test_data4 = [[120, 0.5, 0.2], [220, 0.3, 0.15], [115, 0.45, 0.25]]\n    assert candidate(species_data4, test_data4, 3) == [1, 2, 1]\n\n    species_data5 = [\n        {'portal_id': 1, 'features': [5, 0.5, 0.4]}\n    ]\n    test_data5 = [[5, 0.5, 0.4]]\n    assert candidate(species_data5, test_data5, 1) == [1]", "extra_info": {"cover_story_words": ["portal", "living plants"], "topics": [], "field": ["Machine Learning"], "cleaned_prompt": "Develop a machine learning classifier that predicts the portal based on characteristics of plants. Implement a k-Nearest Neighbours classifier to classify test data. Handle Euclidean distance calculation, determination of k-nearest vectors, and majority vote for classification.\n    Example:\n    Input: species_data=[{'portal_id': 1, 'features': [10, 0.5, 0.2]}, {'portal_id': 2, 'features': [20, 0.3, 0.1]}], test_data=[[10, 0.5, 0.3], [20, 0.3, 0.2]], k=3\n    Output: [1, 2]", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Unclear Data Structure: The problem statement provides an overly complex description of handling the ML model but does not provide adequate exploration of expected feature data characteristics and edge cases like feature normalization, handling categorical data, or missing values, which can significantly impact the model's performance in real scenarios.", "4, Inadequate Error Handling: The problem does not provide guidance on error handling conditions such as when k is larger than the number of available data points, or when all nearest neighbors have the same distance but different portal IDs, which can lead to ambiguous results."]}}
