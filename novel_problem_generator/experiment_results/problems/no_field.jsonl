{"task_id": "hard/5", "prompt": "def enchanted_staircase(n):\n    \"\"\"\n    In an enchanted forest, there's a wise old tree that has a mystical staircase which can have n steps (n being any integer from 1 up to and including 50). Each of the steps might contain certain ancient symbols carved onto it. Each symbol manifests based on the step path taken: either 'leaf' if one step is taken or 'owl' if two steps are taken. To ascend the staircase and gain the wisdom of the wise old tree, one must follow specific rules based on these symbols. \n\n    A traveler can take either 1 or 2 steps at a time. However, the staircase has a magical memory that tracks the last two symbols for each individual step. If anywhere on the staircase the sequence [owl, leaf] appears consecutively on the same step, the staircase collapses, and the journey ends.\n\n    The function should return the total number of distinct ways to ascend the staircase such that it doesn't collapse. As input, you're given the integer n, representing the total number of steps in the staircase.\n\n    Example:\n    - For n = 3, the output should be 3. The valid paths up to the third step are: [leaf, leaf, leaf], [leaf, owl], [owl, leaf]\n    - For n = 4, the output should be 3. The valid paths up to the fourth step are: [leaf, leaf, leaf, leaf], [leaf, leaf, owl], [leaf, owl, leaf].\n\n    Note:\n    - Your algorithm should ensure that paths consisting of [leaf, leaf] or [owl, owl] should be avoided as they can also cause a collapse according to more stringent conditions defined.\n    \"\"\"\n", "canonical_solution": "    def enchanted_staircase(n):\n        if n == 0 or n == 1: return 1\n        dp = [0] * (n+1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, n+1):\n            dp[i] = dp[i-1] + dp[i-2] - (i > 3 and dp[i-4])\n        return dp[n]", "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 1\n    assert candidate(3) == 3\n    assert candidate(4) == 3\n    assert candidate(5) == 4\n    assert candidate(8) == 9\n    assert candidate(12) == 16\n    assert candidate(20) == 61\n    assert candidate(30) == 180\n    assert candidate(50) == 1255", "entry_point": "enchanted_staircase", "extra_info": {"cover_story_words": ["enchanted forest", "wise old tree"], "topics": ["Climbing Stairs", "Dynamic Programming"], "field": "", "cleaned_prompt": "Write a function enchanted_staircase(n) that calculates the distinct methods to climb a staircase of n steps without causing it to collapse, considering symbolic generation based on steps taken and sequences that lead to collapsing. Each step generates a 'leaf' if moved by one step or an 'owl' if moved by two steps.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, contradictory_rules: The problem statement contains contradicting rules regarding which sequences cause the staircase to collapse. Initially, it states that the sequence [owl, leaf] specifically causes a collapse, but later expands this to include [leaf, leaf] and [owl, owl] without clear justification or alignment with the earlier part of the problem description.", "5, incorrect_example: The example provided in the problem description is incorrect based on the rules stated. For n = 4, the output provided is 3, stating that [leaf, owl, leaf] is a valid path, but according to the rule that [owl, leaf] causes collapse, this should not be a valid sequence.", "4, unclear_task_specification: The problem statement sets a rule that a sequence [owl, leaf] causes collapse when on the same step, which is confusing because the narrative about steps involves sequential progress, not simultaneous occupancy of a step by different symbols."]}}
{"task_id": "hard/8", "prompt": "def enchanted_library(codex, magic_sum):\n    \"\"\"\n    On a distant space station, there exists an enchanted library that contains a collection of magical books. Each book in the library has a mystical number associated with it. You are given a list codex that contains the mystical numbers of all books in the library and a magical number magic_sum. Every time a new astronaut arrives at the station, they must perform a ritual by choosing a combination of books such that the sum of the mystical numbers of the selected books equals magic_sum.\n\n    Write a function that returns all possible unique combinations of mystical numbers from the codex (in any order) that sum to magic_sum. Each combination should be a list of numbers, and combinations may include the same number multiple times if it appears multiple times in the codex list.\n\n    Example:\n    - If the input is codex = [2,3,6,7] and magic_sum = 7, the output should be [[7], [2,2,3]] because the possible combinations to get a sum of 7 are [7] and [2,2,3].\n\n    Note:\n    - The result list should not contain any duplicate combinations.\n    - Combination can be in any order.\n    - If no combination can be found that adds up to magic_sum, return an empty list.\n    \"\"\"\n", "canonical_solution": "    def comb_sum(candidates, target, current, start, result):\n        if target == 0:\n            result.append(current[:])\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            comb_sum(candidates, target - candidates[i], current, i, result)\n            current.pop()\n\n    result = []\n    comb_sum(codex, magic_sum, [], 0, result)\n    return result", "test": "def check(candidate):\n    assert sorted(candidate([2, 3, 6, 7], 7)) == sorted([[7], [2, 2, 3]])\n    assert sorted(candidate([2, 2, 4, 6], 8)) == sorted([[2, 2, 2, 2], [2, 6]])\n    assert candidate([5], 5) == [[5]]\n    assert candidate([4, 3, 7], 2) == []\n    assert sorted(candidate([1, 1, 2, 5, 6], 6)) == sorted([[1, 1, 2, 2], [6]])", "entry_point": "enchanted_library", "extra_info": {"cover_story_words": ["enchanted book", "space station"], "topics": ["Combination Sum"], "field": "", "cleaned_prompt": "Write a function that takes a list of integers `codex`, representing mystical numbers associated with books, and an integer `magic_sum`. The function should return all unique combinations of numbers from `codex` that sum to `magic_sum`. Each combination should be a list of integers. Consider duplicates in `codex`, and combinations can be in any order. If no valid combination exists, return an empty list.\n\nExample:\n- For `codex = [2,3,6,7]` and `magic_sum = 7`, the output should be `[[7], [2,2,3]]`.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Incorrect Output in Test Cases: The test cases provided in the problem description and the specifications of the canonical solution do not accurately produce unique combinations as required by the prompt. Specifically, the example with input `test([1, 1, 2, 5, 6], 6)` should not include `[1, 1, 2, 2]` since having two '2's does not match the content of the codex list `[1, 1, 2, 5, 6]`; thus, there is only one '2' available. Therefore, the test case contradicts the stated capabilities of the function, which should respect the duplicate count of elements present in `codex`.", "5, Ambiguity in Combination Generation: The problem statement specifies the function should account for each number's frequency in `codex` when creating combinations. However, it does not clearly specify whether the same number can be reused unlimited times if it is present in the list multiple times. This ambiguity can lead to different implementations, impacting the uniformity and validity of the expected results across various solutions.", "4, Test Cases May Fail on Proper Implementation: The provided test function assumes a specific sorting of the output, which might not align with different but correct implementations based on the ambiguous problem statement concerning order. If combinations are supposed to be unique and order within them is not supposed to matter, the test should account for this rather than impose an unnatural sorting for validation."]}}
{"task_id": "hard/10", "prompt": "def pirate_treasure(combination_weights, capacity):\n    \"\"\"\n    A pirate discovers a cave filled with treasure chests, each filled with gold coins of different weights. The cave has an ancient security system where exceeding a total weight limit triggers deadly traps. The challenge is to determine the maximum weight of gold coins that can be extracted without activating these traps.\n\n    Given an array of integers representing the weight of gold coins in each chest and an integer 'capacity' representing the maximum allowable weight, return the maximum weight of coins that can be carried without surpassing the capacity. You must achieve this by using each chest only once.\n\n    Example:\n    - If `combination_weights` = [2, 3, 5, 7] and `capacity` = 10, the correct output should be 10 because the combinations `2 + 3 + 5` maximize the total weight.\n    - If `combination_weights` = [1, 2, 3, 4] and `capacity` = 5, the optimal load is 5 because you can use `1 + 4`.\n    - If `combination_weights` = [1, 5, 10, 11] and `capacity` = 20, the best choice results in 16 by using `5 + 11`.\n\n    Note:\n    - Each weight represents a distinct chest. Chests can be used in combination as long as the total weight does not exceed the capacity.\n    \"\"\"\n", "canonical_solution": "    def optimal_coin_load(weights, limit):\n        if not weights:\n            return 0\n        dp = [0] * (limit + 1)\n        for w in weights:\n            for j in range(limit, w - 1, -1):\n                dp[j] = max(dp[j], dp[j - w] + w)\n        return dp[limit]\n    return optimal_coin_load(combination_weights, capacity)", "test": "def check(candidate):\n    assert candidate([2, 3, 5, 7], 10) == 10\n    assert candidate([1, 2, 3, 4], 5) == 5\n    assert candidate([1, 5, 10, 11], 20) == 16\n    assert candidate([1, 3, 4, 5], 7) == 7\n    assert candidate([10, 10, 10, 10], 5) == 0\n    assert candidate([], 50) == 0\n    assert candidate([1, 2, 3, 4, 5], 0) == 0", "entry_point": "pirate_treasure", "extra_info": {"cover_story_words": ["pirate ship", "ancient security system", "traps"], "topics": ["Dynamic Programming", "Subset Sum"], "field": "", "cleaned_prompt": {"function_definition": "def pirate_treasure(combination_weights, capacity):\n", "explanation": "Given weights of gold coins in treasure chests and a maximum carrying capacity, calculate the maximum total weight of coins that can be taken without exceeding the capacity, each chest can be used not more than once.\n", "examples": {"example_1": {"combination_weights": [2, 3, 5, 7], "capacity": 10, "output": 10}, "example_2": {"combination_weights": [1, 2, 3, 4], "capacity": 5, "output": 5}, "example_3": {"combination_weights": [1, 5, 10, 11], "capacity": 20, "output": 16}}}, "warnings": ["Solution failed correctness check. reason: failed: ", "5, Mismatch Between Entry Point and Solution Method: The entry point is defined as 'pirate_treasure', but the 'canonical_solution' is using a different function name 'optimal_coin_load'. This will cause the function to not be invoked properly and the problem will be unsolvable without externally defining 'pirate_treasure' in the correct form.", "5, Incorrect Solution Implementation in Problem Statement: The solution provided in 'canonical_solution' is defined with an inline 'optimal_coin_load' function but returns 'optimal_coin_load' as if it was declared outside. This results in incorrect function return scope which could lead to a runtime error of referencing an undefined function. The correct implementation needs to correct the return scope."]}}
{"task_id": "hard/6", "prompt": "def enchanted_instrument_success_probability(events):\n    \"\"\"\n    On a mystical farm, there is an enchanted musical instrument that plays a special song to boost crop growth. The efficiency of the song each day is determined by a sequence of probabilistic events, which form a dependency chain.\n\n    Each event in the sequence can be represented by:\n    - An identifier (a distinct integer).\n    - A list of tuples, where each tuple contains:\n        1. The identifier of a dependent event.\n        2. The conditional probability (a float between 0 and 1) that this specific event succeeds only if the dependent event has also succeeded.\n\n    The goal is to compute the overall probability that the entire sequence of events will succeed in a given day.\n\n    Examples:\n    - Input: [(1, []), (2, [(1, 0.9)]), (3, [(2, 0.8)])]\n      Explanation: Event 1 has no dependencies (always succeeds). Event 2 succeeds with probability 0.9 if Event 1 succeeds. Event 3 succeeds with probability 0.8 if Event 2 succeeds.\n      Calculation: Success probability = 1 * 0.9 * 0.8 = 0.72\n\n    Note:\n    - The dependency graph defined by the list of events will not contain cycles, but your implementation should handle cycles appropriately by returning a probability of zero for such cases.\n    \"\"\"", "canonical_solution": "    def event_success_probability(event, events_dict, cache):\n        if event in cache:\n            return cache[event]\n        dependencies = events_dict[event]\n        if not dependencies:\n            cache[event] = 1.0\n            return 1.0\n        prob = 1.0\n        for parent, p in dependencies:\n            parent_prob = event_success_probability(parent, events_dict, cache)\n            prob *= parent_prob * p\n            if parent_prob == 0.0:  # Handle cycles by detecting zero probability\n                return 0.0 \n        cache[event] = prob\n        return prob\n\n    events_dict = {event: dependencies for event, dependencies in events}\n    cache = {}\n    result = 1.0\n    for event in events_dict:\n        event_prob = event_success_probability(event, events_dict, cache)\n        result *= event_prob\n    return result", "test": "def check(candidate):\n    assert abs(candidate([(1, []), (2, [(1, 0.9)]), (3, [(2, 0.8)])]) - 0.72) < 0.0001\n    assert abs(candidate([(1, [])]) - 1.0) < 0.0001\n    assert abs(candidate([(1, [(2, 0.5)]), (2, [(1, 0.9)])]) - 0.0) < 0.0001  # Handling of cycle\n    assert abs(candidate([(1, []), (2, [(1, 0.95)]), (3, [(2, 0.85)]), (4, [(3, 0.9)])]) - 0.72675) < 0.0001\n    assert abs(candidate([(1, [])]) - 1.0) < 0.0001", "entry_point": "enchanted_instrument_success_probability", "extra_info": {"cover_story_words": ["enchanted instrument", "farm"], "topics": ["Probabilities", "Dependency chain"], "field": "Probabilistic dependencies", "cleaned_prompt": "Given a list of events with their dependencies and respective conditional probabilities, calculate the overall probability that a chain of events in a day all succeed. An event is defined by its identifier and each dependent event has a conditional success probability. The input list of tuples has the format (event identifier, [(dependent event identifier, conditional probability), ...]). Calculate the success probability of the chain of events for a day. The solution should correctly handle cases where cycles in dependencies would otherwise result in an incorrect computation.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 20)", "4, Unclear specification on events with no dependencies: The problem statement does not explicitly specify the probability of events that have no dependencies. Though an example infers that such events always succeed (probability = 1.0), this assumption should be clearly stated as a rule in the prompt for absolute clarity to avoid ambiguity."]}}
{"task_id": "hard/9", "prompt": "def max_loot_time_clock(events, cooldown):\n    \"\"\"\n    In a wild-west themed world with a time-bending clock, a series of events to rob valuable items appear over a time continuum. Each event is described as a tuple (start_time, end_time, loot_value) representing the start and end timing of the event and the value of the loot that can be extracted by attending the event in its entirety.\n\n    However, there's a cooldown mechanism with the time-bending clock such that after attending one event, you can't attend another event that starts within 'cooldown' time after the end of the previous event.\n\n    Write a function that takes a list of events and an integer 'cooldown' and returns the maximum total value of loot that can be collected by optimally choosing events considering the constraints imposed by cooldown. When multiple events can be chosen with the same start time or close end times within the cooldown period, preference should be given to the event with the higher loot value.\n\n    For example:\n    - If events = [(1, 3, 50), (4, 6, 10), (2, 5, 80)] and cooldown = 1, the maximum loot is 130 (attend events indexed at 0 and 1).\n    - If events = [(2, 5, 40), (1, 4, 60), (6, 7, 20), (5, 9, 100)] and cooldown = 1, the maximum sensible choice for loot optimization is the event indexed at 3 for a loot of 100, given earlier overlapping and cooldown issues.\n\n    Note:\n    - No two events can overlap in time.\n    - If there's no valid way to attend any event (due to overlapping times or cooldown constraints), return 0.\n    \"\"\"\n", "canonical_solution": "    events.sort(key=lambda x: (x[1], -x[2]))\n    n = len(events)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_event = events[i - 1]\n        # Find the latest non-overlapping event\n        j = i - 1\n        while j > 0 and events[j - 1][1] + cooldown > current_event[0]:\n            j -= 1\n        dp[i] = max(dp[i - 1], dp[j] + current_event[2])\n    return dp[n]", "test": "def check(candidate):\n    assert candidate([(1, 3, 50), (4, 6, 10), (2, 5, 80)], 1) == 130\n    assert candidate([(2, 5, 40), (1, 4, 60), (6, 7, 20), (5, 9, 100)], 1) == 100\n    assert candidate([(1, 2, 10), (3, 5, 20), (2, 6, 70)], 2) == 70\n    assert candidate([(3, 6, 85), (1, 4, 30), (7, 10, 150)], 1) == 235\n    assert candidate([], 2) == 0\n    assert candidate([(0, 1, 20), (1, 2, 40), (0, 3, 100)], 5) == 100", "entry_point": "max_loot_time_clock", "extra_info": {"cover_story_words": ["time-bending clock", "wild west"], "topics": ["Dynamic Programming", "Interval Scheduling"], "field": "", "cleaned_prompt": "Write a function that takes a list of events (each represented by a tuple containing start time, end time, and loot value) and an integer 'cooldown'. Calculate the maximum total loot that can be collected without overlapping events and considering the cooldown. Events can be sorted and chosen based on their end time and loot value to optimize the loot collection.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Clarification Required in Problem Statement: The problem statement ambiguously states that \"No two events can overlap in time\" but also provides an example where events do overlap. This inconsistency can confuse potential problem solvers as to which events are considered valid between examples; clarification or modification is needed to define allowed event overlaps or adjust examples to avoid them. The given examples seem to consider overlapping times based on the end time and cooldown restrictions, but this contradicts the stated rule of non-overlapping events.", "4, Inadequate Problem Specification on Event Sorting: The problem vaguely describes the preference for higher loot value events without explicitly dictating a sort priority between overlapping events. Since the canonical solution considers events sorted by end time first then by the negative of the loot value, this should be comprehensively outlined in the problem statement to prevent misunderstanding or incorrect implementations.", "4, Example Misalignment with Canonical Solution: The examples provided, particularly implications on event overlaps and cooldown effects, do not fully align with the logic in the canonical solution. There is room for discrepancies when the solution logic is applied to edge cases or scenarios not explicitly covered in examples. More detailed or additional representative examples could avoid potential misunderstandings or incorrect assumptions by problem solvers."]}}
{"task_id": "hard/7", "prompt": "def optimal_gem_distribution(gemstones, reviewers):\n    \"\"\"\n    Imagine you are a consultant for a high-end gemstone mine, which has recently discovered treasures requiring unique expertise to evaluate. Each gemstone is unique in its value and rarity. Besides, there is a list of expert reviewers, each with a probability of approving a gemstone based on its characteristics.\n\n    You need to distribute the gemstones among the reviewers such that the probability of getting all gemstones approved is maximized, even if the numbers of gemstones and reviewers are different.\n\n    The gemstones are represented as a list of tuples (value, rarity) where value is an integer and rarity is a float.\n    The reviewers are represented as a list of functions, where each function takes a gemstone tuple and returns the probability (0 <= p <= 1) of that reviewer approving the gemstone.\n\n    The function should return a distribution list where each element is a tuple (reviewer_index, gemstone_index) indicating that the gemstone at gemstone_index is assigned to the reviewer at reviewer_index to maximize the overall probability of approval. If there are more gemstones than reviewers, each reviewer can review more than one gemstone; if there are more reviewers than gemstones, some reviewers may not receive a gemstone.\n\n    Example:\n    gemstones = [(10, 0.2), (20, 0.5), (30, 0.3)]\n    reviewers = [\n        lambda g: 0.9 if g[1] < 0.3 else 0.2,\n        lambda g: 0.7 if g[0] > 15 else 0.1\n    ]\n    The output should be [(0, 0), (1, 1), (0, 2)] as it maximizes the overall probability of approval.\n\n    Note:\n    - Be sure to handle the cases where the number of gemstones and reviewers are different.\n    \"\"\"", "canonical_solution": "    from itertools import permutations\n    import numpy as np\n    def total_probability(distribution):\n        product = 1\n        for reviewer_idx, gemstone_idx in distribution:\n            product *= reviewers[reviewer_idx](gemstones[gemstone_idx])\n        return product\n\n    max_probability = 0\n    optimal_distribution = []\n    for perm in permutations(range(len(reviewers)), len(gemstones)):\n        distribution = list(zip(range(len(reviewers)), np.random.permutation(perm)))\n        current_probability = total_probability(distribution)\n        if current_probability > max_probability:\n            max_probability = current_probability\n            optimal_distribution = distribution\n\n    return optimal_distribution", "test": "def check(candidate):\n    gemstones1 = [(10, 0.2), (20, 0.5), (30, 0.3)]\n    reviewers1 = [\n        lambda g: 0.9 if g[1] < 0.3 else 0.2,\n        lambda g: 0.7 if g[0] > 15 else 0.1\n    ]\n    assert set(candidate(gemstones1, reviewers1)) == set([(0, 0), (1, 1), (0, 2)])\n\n    gemstones2 = [(5, 0.5), (15, 0.1), (25, 0.4), (35, 0.2)]\n    reviewers2 = [\n        lambda g: 0.8 if g[1] < 0.25 else 0.3,\n        lambda g: 0.6 if g[0] < 20 else 0.2\n    ]\n    assert set(candidate(gemstones2, reviewers2)) == set([(0, 1), (0, 3), (1, 0), (1, 2)])\n\n    gemstones3 = [(12, 0.15), (22, 0.55)]\n    reviewers3 = [\n        lambda g: 0.85 if g[1] < 0.5 else 0.15,\n        lambda g: 0.65 if g[0] > 20 else 0.05\n    ]\n    assert set(candidate(gemstones3, reviewers3)) == set([(0, 0), (1, 1)])\n\n    gemstones4 = [(10, 0.1)]\n    reviewers4 = [lambda g: 0.8 if g[1] < 0.2 else 0.1, lambda g: 0.9 if g[1] < 0.2 else 0.2]\n    assert set(candidate(gemstones4, reviewers4)) == set([(1, 0)])\n\n    gemstones5 = [(10, 0.1), (15, 0.2), (20, 0.3)]\n    reviewers5 = [lambda g: 0.9 if g[1] < 0.3 else 0.1]\n    assert set(candidate(gemstones5, reviewers5)) == set([(0, 0), (0, 1), (0, 2)])", "entry_point": "optimal_gem_distribution", "extra_info": {"cover_story_words": ["gemstone mine", "restaurant"], "topics": ["Probability and Statistics", "Jarvis March"], "field": "", "cleaned_prompt": "Write a function that takes a list of gemstone tuples (value, rarity) and a list of reviewer functions. Each reviewer function takes a gemstone tuple and returns the probability of approving the gemstone. The function should return a list of tuples (reviewer_index, gemstone_index) to maximize the probability of all gemstones getting approved. - Gemstones are represented as (value, rarity) tuples. - Reviewers are functions returning probabilities based on gemstone characteristics. - Handle different counts of gemstones and reviewers. Each reviewer can handle multiple gemstones or may not receive any, depending on the counts.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 22)", "4, Ambiguity in Problem Statement: The problem statement is unclear about the expected behaviour or method of 'maximizing the overall probability of approval' when the distribution possibilities of gemstones to reviewers can significantly vary. This results in an exponential number of combinations to evaluate, which may not be tractable for a larger set of gemstones and reviewers.", "5, Unsolvable Complexity: No feasible solution is provided to handle combinations efficiently when the number of gemstones and reviewers differ. The combinations\u2019 factor increases non-linearly, making brute-force or permutation-based approaches impractical for larger inputs. The solution attempts to utilize permutations, but it falls short of efficiently handling complex cases and large inputs.", "5, Inequity in Assignment Distribution Strategy: The problem does not specify how to ensure fairness or a technically sound distribution when there are more reviewers than gemstones or vice versa. Without such guidance or constraints, solutions might be overly simplified or unfairly distribute workloads, leading to suboptimal or misunderstood implementation efforts."]}}
{"task_id": "hard/1", "prompt": "def ghostly_sum_events(ghost_events, energy_threshold):\n    \"\"\"\n    In an old haunted house, paranormal investigators use sensors to detect ghostly energy disturbances. Each disturbance emits an energy value, and these events come as an uninterrupted data stream. The investigators are particularly interested in discovering pairs of events whose summed energy precisely matches a given energy threshold to confirm a potent 'energy vortex'.\n\n    Implement a function that, given a list of integers (representing energy disturbances as they are detected) and an integer (the energy threshold), determines how many pairs of disturbances sum up exactly to the given threshold. Each disturbance may only be used once, and the function should return the count of unique pairs where the order of events in a pair does not matter.\n\n    For example:\n    ghostly_sum_events([5, 3, 6, 2], 8) should return 2, with pairs (5, 3) and (6, 2) summing to 8.\n    ghostly_sum_events([1, 1, 3, 5], 4) should return 1, with a qualifying pair being (1, 3).\n\n    \"\"\"\n", "canonical_solution": "    def ghostly_sum_events(ghost_events, energy_threshold):\n        seen = {}\n        count = 0\n        for e in ghost_events:\n            complement = energy_threshold - e\n            if complement in seen and seen[complement] > 0:\n                count += 1\n                seen[complement] -= 1\n            else:\n                if e in seen:\n                    seen[e] += 1\n                else:\n                    seen[e] = 1\n        return count", "test": "def check(candidate):\n    assert candidate([5, 3, 6, 2], 8) == 2\n    assert candidate([1, 1, 3, 5], 4) == 1\n    assert candidate([10, 3, 5, 2], 5) == 0\n    assert candidate([0, 0, 0, 0], 0) == 6\n    assert candidate([100, 1, 42, -42, 100], 58) == 1\n    assert candidate([4, -2, 7, -5, 11, 5, -4], 9) == 1\n    assert candidate([1, 5, 1, 5], 10) == 0\n    assert candidate([-7, -3, 10, 4, 2, 0, -10], 0) == 2\n    assert candidate([-5, 12, 6, 3, 9, 2, 1, -8], 4) == 4\n    assert candidate([15, 5, -10, -5, -15, 10], 0) == 3", "entry_point": "ghostly_sum_events", "extra_info": {"cover_story_words": ["haunted house", "energy vortex"], "topics": ["Data Stream", "Two-Sum Problem"], "field": "", "cleaned_prompt": "Given a list of integers representing energy disturbances in a haunted house and an integer energy threshold, count how many unique pairs of disturbances sum precisely to the energy threshold. Only count pairs where disturbances are used once. For example:\nghostly_sum_events([5, 3, 6, 2], 8) should return 2, since the pairs (5, 3) and (6, 2) both sum to 8.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, insufficient definition of 'unique pairs': The problem statement does not clearly explain what constitutes 'unique pairs' especially with regards to handling multiple identical pairs. This can create ambiguity if the input contains duplicate values leading to multiple identical sum pairs.", "5, tuple order irrelevance not explicitly managed in canonical solution: The problem statement asserts that the order of pairs does not matter in counting unique pairs. However, the canonical solution does not have a mechanism to ensure that pairs such as (1, 3) and (3, 1) are counted as a single unique pair due to how dictionaries manage keys and values, potentially leading to incorrect counts when identical values are present in different orders.", "4, handling of repeated elements: The canonical solution's mechanism to decrement the count in 'seen' dictionary for the complement is flawed for handling repeated elements appropriately in certain cases, possibly giving incorrect results. There needs to be clarification or adjustment in logic to accurately track and decrement counts of elements used in pairs."]}}
{"task_id": "hard/3", "prompt": "def find_optimal_wind_route(matrix):\n    \"\"\"\n    Imagine navigating a grid where each cell depicts wind resistance at that location with a tuple in the format (incoming_strength, outgoing_strength). Here, 'incoming_strength' is the resistance experienced when entering the cell and 'outgoing_strength' is the resistance when leaving the cell.\n\n    Your task is to move from the top-left corner (starting point) to the bottom-right corner (destination) of the grid, minimizing the total resistance experienced. You can only move right or down, and moving into a new cell incurs the 'incoming_strength' at that cell as a cost.\n\n    Write a function to calculate the minimum total resistance required to traverse the matrix.\n\n    Example:\n    Input: [\n        [(0, 2), (3, 1)],\n        [(1, 4), (2, 0)]\n    ]\n    Output: 1 (Right from (0,0) costing 3 to (0,1), then Down from (0,1) costing 0 to (1,1))\n\n    Notes:\n    - The matrix will always be a non-empty 2D array.\n    - Each tuple in the matrix contains non-negative integers.\n    \"\"\"", "canonical_solution": "    def find_optimal_wind_route(matrix):\n        m, n = len(matrix), len(matrix[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        for i in range(m):\n            for j in range(n):\n                if j + 1 < n:\n                    dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + matrix[i][j+1][0])\n                if i + 1 < m:\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + matrix[i+1][j][0])\n        return dp[-1][-1]", "test": "def check(candidate):\n    assert candidate([[(0, 2), (3, 1)], [(1, 4), (2, 0)]]) == 1\n    assert candidate([[(1, 2), (2, 2), (3, 4)], [(4, 0), (5, 1), (1, 3)], [(1, 1), (2, 0), (0, 2)]]) == 3\n    assert candidate([[(2, 0)], [(1, 5)]]) == 0\n    assert candidate([[(0, 1), (1, 0)], [(3, 2), (1, 4)]]) == 2\n    assert candidate([[(1, 3), (1, 3), (1, 3)], [(2, 1), (2, 1), (2, 1)], [(3, 0), (3, 0), (3, 0)]]) == 7", "entry_point": "find_optimal_wind_route", "extra_info": {"cover_story_words": ["wind resistance", "grid navigation"], "topics": ["Dynamic Programming", "Grid Traversal"], "field": "", "cleaned_prompt": "Write a function to calculate the minimum total resistance required to traverse a grid from the top-left to the bottom-right. Each cell has a tuple (incoming_strength, outgoing_strength), and moving to a new cell costs the 'incoming_strength' of that cell. The goal is to determine the path with the minimum total resistance.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 19)", "5, Misinterpretation in Problem Statement: The problem prompt includes an example that does not take into account the 'outgoing_strength' for each movement, which conflicts with the tuple descriptions provided in the matrix. This leads to ambiguity on whether the 'outgoing_strength' should play a role in the cost calculation, making the problem unsolvable as stated.", "4, Lack of Edge Case Testing: The test cases do not explicitly check for minimal edge (1x1 grid) or with unusual patterns of wind strength that may cause irregular routes, which are essential to determine the robustness of the solution under diverse conditions."]}}
{"task_id": "hard/4", "prompt": "def cave_exploration(grid):\n    \"\"\"\n    In a museum display, there is a representation of a mysterious cave system arranged as a 2D grid. Each section of the grid can either be a wall ('W'), an empty space ('E'), or a treasure ('T'). The task is to find all the treasure which is in one 'strongly connected' space without moving diagonally.\n\n    A 'strongly connected' space is defined as regions connected orthogonally (up, down, left, or right) without any interruptions by walls. Each unique space can be considered a separate cave. Within each cave, if there is at least one treasure ('T'), then all empty spaces ('E') and the treasures in that cave are considered part of the treasure area.\n\n    Your function should return a list of integers where each integer represents the size of a treasure area in any cave found in the grid, sorted in descending order.\n\n    For example, given the grid:\n        [\n         ['E', 'W', 'T'],\n         ['T', 'W', 'E'],\n         ['E', 'E', 'T']\n        ]\n    The grid has two distinct caves. One cave comprises elements {'E'} on the most left column and the other contains the elements {'T', 'E', 'T', 'E', 'E'} where we count the two top items connected despite being separated by 'W' in the original definition.\n\n    Note:\n    - There can be multiple caves and even nested caves. Nested caves are treated as multiple unique caves.\n    - Only consider horizontal and vertical connections, no diagonal.\n    - Treat each 'T' as part of the returned size if it belongs to the cave with treasures.\n    \"\"\"\n", "canonical_solution": "    def dfs(grid, x, y, visited):\n        n, m = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        stack = [(x, y)]\n        size = 0\n        has_treasure = False\n        while stack:\n            cx, cy = stack.pop()\n            if (cx, cy) in visited:\n                continue\n            visited.add((cx, cy))\n            if grid[cx][cy] == 'W':\n                continue\n            if grid[cx][cy] == 'T':\n                has_treasure = True\n            size += 1\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != 'W':\n                    stack.append((nx, ny))\n        return size if has_treasure else 0\n\n    def cave_exploration(grid):\n        visited = set()\n        treasure_sizes = []\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if (i, j) not in visited and grid[i][j] != 'W':\n                    size = dfs(grid, i, j, visited)\n                    if size > 0:\n                        treasure_sizes.append(size)\n        treasure_sizes.sort(reverse=True)\n        return treasure_sizes", "test": "def check(candidate):\n    assert candidate([\n        ['E', 'W', 'T'],\n        ['T', 'W', 'E'],\n        ['E', 'E', 'T']\n    ]) == [5]\n    assert candidate([\n        ['W', 'W', 'W'],\n        ['W', 'W', 'W'],\n        ['W', 'W', 'W']\n    ]) == []\n    assert candidate([\n        ['E', 'E'],\n        ['T', 'T']\n    ]) == [4]\n    assert candidate([\n        ['T', 'W'],\n        ['E', 'E']\n    ]) == [1]\n    assert candidate([\n        ['E', 'T', 'E', 'W', 'T'],\n        ['W', 'E', 'W', 'W', 'E'],\n        ['E', 'T', 'E', 'E', 'T']\n    ]) == [7, 1]", "entry_point": "cave_exploration", "extra_info": {"cover_story_words": ["museum", "mysterious cave"], "topics": ["Divide and Conquer", "Strongly Connected Component"], "field": "", "cleaned_prompt": "def cave_exploration(grid):\n    \"\"\"\n    Given a grid representing a cave system, where each cell can be a wall ('W'), an empty space ('E'), or a treasure ('T'), return a list of the size of each 'strongly connected' treasure area sorted in descending order.\n\n    - Use Depth-First Search to explore caves.\n    - Count size of treasure area in caves.\n    - Only explore orthogonal connections, no diagonals are considered.\n    \"\"\"", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Incorrect Example Explanation: The problem statement contains an example explanation that contradicts the defined problem behavior. Specifically, it states that elements separated by a 'W' are counted together, which defies the intended logic of treating 'W' as an interruption in the connection of cave regions.", "5, Misleading Problem Description: The prompt's definition of 'strongly connected' and the handling of orthogonal connections appear to be incorrectly applied in the example provided. This can lead to confusion and incorrect implementations as the example suggests connectivity that should not exist per the initial rules.", "4, Test Case Validity: The test cases provided in the problem statement may lead to incorrect solutions being considered correct, or vice versa, especially with how connectivity through walls ('W') is handled. This could result in erroneous assumptions and a failure in accurately testing the core functionality of the solution."]}}
{"task_id": "hard/2", "prompt": "def interdimensional_timeflow(paths, queries):\n    \"\"\"\n    In a world where parallel universes and time-bending devices exist, there is a unique temporal device called the Interdimensional Timeflow Manipulator. This device interconnects multiple universes with pathways that allow the bidirectional flow of time particles. Each pathway has a capacity limit representing the maximum amount of time particles that can be transmitted in each direction within a unit of time.\n\n    Your task is to model this network as a bidirectional flow problem where each node represents a universe, and each edge has a bidirectional capacity associated with it.\n\n    The function 'interdimensional_timeflow' should take the following parameters:\n    - paths: A list of tuples representing the connections between universes. Each tuple is in the form (universe1, universe2, capacity), specifying that the connection is bidirectional with the given capacity.\n    - queries: A list of tuples representing requests to move a certain volume of time particles between two universes. Each tuple is in the form (source_universe, destination_universe, desired_flow).\n\n    The function should return a list of booleans, where each boolean corresponds to whether the desired flow in the corresponding query is possible within the constraints of the network. You are expected to implement an efficient algorithm suitable for potentially large networks.\n\n    Example:\n    If paths = [(1, 2, 10), (2, 3, 5), (1, 3, 10)], and queries = [(1, 3, 15), (1, 2, 5)],\n    The result should be [True, True] because:\n    - The maximum flow from universe 1 to 3 is 15, which accommodates the first query.\n    - The maximum flow from universe 1 to 2 is 10, more than the 5 required by the second query.\n    \"\"\"", "entry_point": "interdimensional_timeflow", "canonical_solution": "    from collections import defaultdict, deque\n\n    def bfs(capacity, source, sink, parent):\n        visited = [False] * len(capacity)\n        queue = deque([source])\n        visited[source] = True\n\n        while queue:\n            u = queue.popleft()\n\n            for v, cap in enumerate(capacity[u]):\n                if not visited[v] and cap > 0:  # Not yet visited and capacity left\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == sink:\n                        return True\n        return False\n\n    def edmonds_karp(capacity, source, sink):\n        n = len(capacity)\n        parent = [-1] * n\n        max_flow = 0\n\n        while bfs(capacity, source, sink, parent):\n            path_flow = float('Inf')\n            s = sink\n\n            while s != source:\n                path_flow = min(path_flow, capacity[parent[s]][s])\n                s = parent[s]\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                capacity[u][v] -= path_flow\n                capacity[v][u] += path_flow\n                v = u\n\n            max_flow += path_flow\n\n        return max_flow\n\n    node_count = max(max(u, v) for u, v, _ in paths) + 1\n    capacity = [[0] * node_count for _ in range(node_count)]\n\n    for u, v, cap in paths:\n        capacity[u][v] += cap\n        capacity[v][u] += cap\n\n    result = []\n    for source, sink, flow in queries:\n        if edmonds_karp(capacity, source, sink) >= flow:\n            result.append(True)\n        else:\n            result.append(False)\n\n    return result", "test": "def check(candidate):\n    assert candidate([(1, 2, 10), (2, 3, 5), (1, 3, 10)], [(1, 3, 15), (1, 2, 5)]) == [True, True]\n    assert candidate([(0, 1, 3), (1, 2, 4), (2, 3, 5), (3, 4, 6), (4, 0, 7)], [(0, 3, 10), (1, 4, 9), (0, 2, 3)]) == [False, True, True]\n    assert candidate([(1, 2, 7), (2, 3, 6)], [(1, 3, 13), (1, 3, 12)]) == [False, False]\n    assert candidate([(0, 1, 100), (1, 2, 100), (0, 2, 1)], [(0, 2, 1), (1, 2, 100), (0, 2, 101)]) == [True, True, False]\n    assert candidate([(0, 1, 7), (1, 2, 6), (2, 3, 5), (3, 0, 6)], [(0, 3, 16)]) == [False]", "extra_info": {"cover_story_words": ["time-bending clock", "parallel universe"], "topics": ["Trie", "Maximum Flow Problem"], "field": "", "cleaned_prompt": "", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 18)", "5, Unrealistic Example: The example provided in the prompt states that the maximum flow from universe 1 to 3 is 15 using paths (1, 2, 10) and (2, 3, 5), which is incorrect. According to the provided paths, the maximum flow from universe 1 to 3 should be only 5. This discrepancy between the description and actual network flow principles could lead to confusion."]}}
