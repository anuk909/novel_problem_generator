{"task_id": "hard/7", "prompt": "def correct_messages_for_sun_library(messages, key):\n    \"\"\"\n    A library in Sun Village is facing a problem. Every day they receive encrypted digital messages that should be displayed on the welcome screen. However, the library system is old and tends to corrupt the encrypted messages by randomly switching characters within each message. Your task is to write a function that decrypts these messages using a given key and then corrects them by finding the lexicographically smallest rotation.\n\n    Each message is decrypted by XOR-ing the ASCII values of its characters with the key. After decryption, to correct the message, find the lexicographically smallest rotation of the resulting string.\n\n    The function takes two parameters: a list of encrypted messages (string list) and an integer key. The function should return a list of corrected decrypted messages.\n\n    Example:\n    messages = ['Cde', 'Bfg']\n    key = 2\n    Output: ['abc', 'def']\n    Explanation:\n    - 'Cde' -> Decoded with key 2: 'abc' (then rotated to 'abc')\n    - 'Bfg' -> Decoded with key 2: 'def' (then rotated to 'def')\n    The decrypted strings are rotated to achieve the smallest lexicographical order.\n    \"\"\"", "canonical_solution": "    def rotate_to_min(s):\n        return min(s[i:] + s[:i] for i in range(len(s)))\n\n    def correct_messages_for_sun_library(messages, key):\n        corrected_messages = []\n        for message in messages:\n            decrypted = ''.join(chr(ord(char) ^ key) for char in message)\n            min_rotation = rotate_to_min(decrypted)\n            corrected_messages.append(min_rotation)\n        return corrected_messages", "test": "def check(candidate):\n    assert candidate(['Cde', 'Bfg', 'Zgh'], 2) == ['abc', 'def', 'xyz']\n    assert candidate(['Ifmmp$', 'xPsmE!'], 1) == ['helloz', 'worldz']\n    assert candidate(['Vjg', 'uwrgt'], 1) == ['the', 'super']\n    assert candidate([], 10) == []\n    assert candidate(['qRs'], 4) == ['mno']", "entry_point": "correct_messages_for_sun_library", "extra_info": {"cover_story_words": ["library", "sleepy sun"], "topics": ["String Manipulation", "Rotation", "Decryption"], "field": ["Cybersecurity"], "cleaned_prompt": "def correct_messages_for_sun_library(messages, key):\n    \"\"\"\n    Decrypt messages encoded with XOR using a given key and correct by finding the smallest lexicographical rotation.\n\n    Parameters:\n    - messages: List of encrypted message strings.\n    - key: Integer used for decryption.\n\n    Returns:\n    - Decrypted and correctly rotated messages as a list.\n    \"\"\"", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 17)", "4, Ambiguity in Character Set: The prompt does not specify the expected character set for the input strings. This could lead to different results depending on the interpretation, particularly for non-alphanumeric characters (like '!', '$').", "4, Definition of \"Correct\" Rotation: It's not clearly explained why the lexicographically smallest rotation is considered the \"correct\" one for display purposes beyond the technical decryption. The rationale behind this selection criterion could use further elaboration to avoid confusion about the goals of the function."]}}
{"task_id": "hard/4", "prompt": "def harvest_schedule(times, music_intervals):\n    \"\"\"\n    On the farm, you need to schedule the harvest operations in such a way to optimize the periods when background music is played. Music intervals are periods when music is played in a continuous loop on the farm and it is believed to enhance the efficiency of the harvesting robots.\n\n    Given a list 'times' where each element represents a period of time when the farm needs to be harvested, and a list 'music_intervals' which represents the times when music will be played, write a function to find the maximum coverage of harvest times by the music intervals. A music interval can be applied to exactly one harvest time and must start no earlier than the harvest start, and complete no later than the harvest end.\n\n    Each entry in 'times' and 'music_intervals' is a tuple (start, end) representing start and end times.\n\n    Example:\n    If times = [(1, 5), (6, 10), (11, 15)] and music_intervals = [(1, 4), (6, 10), (12, 14)], \n    the maximum coverage would be 3 because:\n    - The interval (1, 4) aligns exactly within (1, 5)\n    - The interval (6, 10) perfectly matches (6, 10)\n    - The interval (12, 14) fits properly within (11, 15)\n    \"\"\"\n", "canonical_solution": "    def harvest_schedule(times, music_intervals):\n        times.sort()\n        music_intervals.sort()\n        result = 0\n        j = 0\n\n        for time_start, time_end in times:\n            while j < len(music_intervals) and music_intervals[j][1] <= time_end:\n                if music_intervals[j][0] >= time_start:\n                    result += 1\n                    j += 1\n                    break\n                j += 1\n        return result", "test": "def check(candidate):\n    assert candidate([(1, 5), (6, 10), (11, 15)], [(1, 4), (6, 10), (12, 14)]) == 3\n    assert candidate([(1, 3), (4, 5)], [(1, 3), (4, 4)]) == 2\n    assert candidate([(5, 7), (8, 10)], [(5, 7), (8, 10)]) == 2\n    assert candidate([(1, 10)], [(2, 3), (4, 7), (8, 9)]) == 1\n    assert candidate([], []) == 0\n    assert candidate([(1, 5), (6, 10)], [(2, 4), (6, 10)]) == 2", "entry_point": "harvest_schedule", "extra_info": {"cover_story_words": ["music", "farm"], "topics": ["Greedy", "Interval Scheduling"], "field": ["Machine Learning"], "cleaned_prompt": "Write a function harvest_schedule that takes a list 'times' (periods when farm needs harvesting) and 'music_intervals' (times music is played). Each music interval can be applied to exactly one harvest time and must start no earlier than the harvest start and end no later than the harvest end. The function should maximize the number of harvest periods covered by music intervals and return this count.\n\nExamples:\n- For times = [(1, 5), (6, 10), (11, 15)] and music_intervals = [(1, 4), (6, 10), (12, 14)], the function should return 3.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Ambiguity in Instructions: The problem statement is ambiguous about how to deal with overlaps and priorities in the music intervals when multiple intervals can fit within a single harvest time or when a music interval can fit multiple harvest times. This lack of clarity can lead to different interpretations and implementations.", "4, Unspecified Time Constraints: The problem description does not specify any constraints on the duration or number of time intervals and music intervals. Inefficient algorithms might not handle large inputs effectively, and without these constraints, it's hard to design a well-optimized solution."]}}
{"task_id": "hard/5", "prompt": "def haunted_treasure_diary(diary_entries, treasure_coords):\n    \"\"\"\n    In a scenario where you're exploring a haunted house, you discover an old diary peppered with hints to hidden treasures expressed in coordinates embedded in DNA-like sequence strings. Each diary entry, composed of the characters 'A', 'C', 'G', 'T', encodes a potential treasure location.\n\n    Given a list of these string entries and real-world treasure coordinates as tuples (x, y), determine which treasure coordinates are most likely represented in the diary using a KD-Tree algorithm for efficient nearest-neighbor searching.\n\n    Entries are decoded to coordinates by counting occurrences of each character:\n    - 'A' adds positively to the x-coordinate\n    - 'C' subtracts from the x-coordinate\n    - 'G' adds positively to the y-coordinate\n    - 'T' subtracts from the y-coordinate\n\n    The 'closeness' between the decoded points and actual treasures is determined using Euclidean distance where the nearest point in the KD-Tree represents a likely match.\n\n    Example:\n    diary_entries = ['AAGCT', 'CCGTAA', 'TTGG'],\n    treasure_coords = [(2, 1), (3, -1), (-1, 1)],\n    The output should be [(2, 1)] as the treasure at (2, 1) closely corresponds to the diary entry 'AAGCT'.\n\n    Notes:\n    - A diary entry could potentially describe multiple treasures if distances are equivalent.\n    - Diary entries and treasure points could have varying scales.\n    \"\"\"\n", "canonical_solution": "    from scipy.spatial import KDTree\n    def decode(entry):\n        x = entry.count('A') - entry.count('C')\n        y = entry.count('G') - entry.count('T')\n        return x, y\n\n    decoded_points = [decode(entry) for entry in diary_entries]\n    tree = KDTree(treasure_coords)\n    closest = set()\n    for point in decoded_points:\n        _, i = tree.query(point)\n        closest.add(tuple(treasure_coords[i]))\n\n    return list(closest)", "test": "def check(candidate):\n    assert candidate(['AAGCT', 'CCGTAA', 'TTGG'], [(2, 1), (3, -1), (-1, 1)]) == [(2, 1)]\n    assert candidate(['AAAA', 'CCCC', 'GGGG', 'TTTT'], [(4, 0), (-4, 0), (0, 4), (0, -4)]) == [(4, 0), (-4, 0), (0, 4), (0, -4)]\n    assert candidate(['ACGT', 'TGCA'], [(0, 0)]) == [(0, 0)]\n    assert candidate(['AAAACCCCGGGGTTTT', 'AAGCT'], [(10, 10), (2, 1)]) == [(10, 10), (2, 1)]\n    assert candidate(['GGG'], [(0, 3)]) == [(0, 3)]", "entry_point": "haunted_treasure_diary", "extra_info": {"cover_story_words": ["haunted house", "treasure"], "topics": ["String", "KD-Tree"], "field": ["Bioinformatics"], "cleaned_prompt": "Given a list of string diary entries encoded with characters 'A', 'C', 'G', 'T' which map to masked coordinates, and a list of real treasure coordinates as tuples, return the list of treasure coordinates that, using a KD-Tree algorithm and Euclidean distance as the measure of closeness, are most likely to be described by the diary entries.", "warnings": ["Solution failed correctness check. reason: failed: 'NoneType' object is not callable", "4, Ambiguous Problem Specification: The prompt does not clearly specify how to handle multiple entries matching the same treasure coordinate with identical distances or how to manage multiple entries potentially mapping to multiple treasures equally. This ambiguity could lead to different interpretations and implementations, affecting the consistency and comparability of solutions."]}}
{"task_id": "hard/10", "prompt": "def pirate_treasure_jump(gems):\n    \"\"\"\n    A group of pirates has discovered a gemstone mine on an island. The mine contains various types of gems, each placed at specific positions in a straight line. The pirates want to collect as many unique types of gems as possible. However, due to the unstable nature of the mine, each jump a pirate makes must be at least the value of the current gem they're standing on and within the bounds of the gem array.\n\n    Given a list of integers representing the gems, where each gem is marked by a unique identifier (positive integer), write a function that determines the maximum number of unique gem types a pirate can collect starting from the first gem. The pirate can only jump forward by at least the number indicated by the current gem's identifier, and must consider all reachable gems considering this constraint.\n\n    For example, if the input is [2, 3, 1, 4, 3], starting from the first gem (2), the possible positions the pirate can jump to are [4]. From gem 4, he can only jump out of the list, thus he can collect gem types 2 and 4.\n\n    Note:\n    - Pirates start at the first gem in the list.\n    - Ensure your function handles various combinations optimally and account for edge cases like empty gem list (return 0 in that case).\n\n    Example assertions:\n    - For gems = [2, 3, 1, 2, 4], the function should return 2 (collects gems 2 and 4).\n    - For an empty list of gems, the function should return 0.\n    \"\"\"\n", "canonical_solution": "    def pirate_treasure_jump(gems):\n        if not gems:\n            return 0\n        unique_gems = set()\n        i = 0\n        while i < len(gems):\n            current_gem = gems[i]\n            next_pos = i + current_gem\n            if next_pos >= len(gems):\n                unique_gems.add(current_gem)\n                break\n            unique_gems.add(current_gem)\n            i = next_pos\n        return len(unique_gems)", "test": "def check(candidate):\n    assert candidate([2, 3, 1, 2, 4]) == 2\n    assert candidate([2, 3, 1, 4, 3]) == 2\n    assert candidate([1, 2, 3, 4, 5]) == 1\n    assert candidate([5, 4, 3, 2, 1]) == 1\n    assert candidate([]) == 0\n    assert candidate([1, 1, 1, 1, 1, 1, 1]) == 1", "entry_point": "pirate_treasure_jump", "extra_info": {"cover_story_words": ["gemstone mine", "pirate ship"], "topics": ["Two-Sum Problem", "Jump Game"], "field": ["Computer Vision"], "cleaned_prompt": "def pirate_treasure_jump(gems):\n    Given a list of integers representing gems each marked by a unique identifier, write a function to determine the maximum number of unique gem types a pirate can collect starting from the first gem, jumping forward by at least the number indicated by the current gem's identifier. Include all reachable gems considering this constraint.\n\n    Examples:\n    - Input: [2, 3, 1, 2, 4], Output: 2\n    - Input: [], Output: 0\n", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Ambiguous Problem Statement: The problem does not clarify whether the gem identifier is directly linked to jump value. The examples given where \"gem is marked by a unique identifier\" could be misunderstood such that each gem's identifier also determines its value for jumping purposes. This may lead to confusion in discerning between gem identifiers and the values to be used for jump calculations.", "4, Inadequate Example Assertions: The provided test cases are limited and do not cover several edge cases like having multiple gems with the same identifier or more complex jump sequences which test algorithm efficiency and correctness.", "4, Non-optimal Algorithm Warning: Although labeled as a \"warning\" under \"extra_info\", it suggests significant flaws in problem execution and solution strategy. It is implied that the canonical solution may not handle all legal jumps efficiently, which is critical for ensuring the algorithm handles larger or more complicated inputs accurately."]}}
{"task_id": "hard/2", "prompt": "def can_split_glowing_creatures(energy_levels):\n    \"\"\"\n    You've discovered an undersea cave filled with bioluminescent creatures. Each creature emits a unique glow, represented by an integer in the list `energy_levels`. To reveal hidden treasures, it's essential to split these creatures into two groups with properties related to their glow.\n\n    Your task is to determine if it's possible to split these creatures into two groups such that the sum of energy levels in each group is the same, and the bitwise XOR of all elements within each group must also be zero.\n\n    Return True if such a partition is possible, and False otherwise.\n\n    Examples:\n    can_split_glowing_creatures([10, 10, 0, 0]) should return True because you can split them into two groups: [10, 0] and [10, 0], where both groups have equal sum and XOR of elements is zero in each group.\n    can_split_glowing_creatures([3, 5, 6, 9]) should return False as no valid partition meets the conditions.\n\n    Note:\n    - The list will always contain non-negative integers.\n    - The importance of both conditions (equal sum and XOR) is crucial for the successful treasure revelation.\n    \"\"\"\n", "canonical_solution": "    def can_split_glowing_creatures(energy_levels):\n        from functools import lru_cache\n        total_sum = sum(energy_levels)\n        if total_sum % 2 != 0:\n            return False\n        target = total_sum // 2\n\n        @lru_cache(None)\n        def can_partition(index, current_sum, current_xor):\n            if index == len(energy_levels):\n                return current_sum == target and current_xor == 0\n            current_val = energy_levels[index]\n            return (can_partition(index + 1, current_sum + current_val, current_xor ^ current_val) or\n                    can_partition(index + 1, current_sum, current_xor))\n\n        return can_partition(0, 0, 0)", "test": "def check(candidate):\n    assert candidate([10, 10, 0, 0]) is True\n    assert candidate([3, 5, 6, 9]) is False\n    assert candidate([2, 2, 2, 2, 4]) is False\n    assert candidate([0, 0, 0, 0]) is True\n    assert candidate([15, 5, 5, 20, 5]) is False", "entry_point": "can_split_glowing_creatures", "extra_info": {"cover_story_words": ["bioluminescent ocean", "treasure"], "topics": ["Partition Equal Subset Sum", "Bitwise XOR Operations"], "field": ["Robotics"], "cleaned_prompt": "Determine if it is possible to split a list of non-negative integers, representing bioluminescent creatures' energy levels, into two groups such that both the sum and the bitwise XOR of all the integers in each group are zero. Include clear examples in the explanation.", "warnings": ["Solution failed correctness check. reason: failed: ", "4, Ambiguity in requirements: The problem statement is ambiguous about the condition that both the sum and the bitwise XOR of all integers in each group should be zero. It specifies that these values should be the same for both groups, but does not clarify if each group's sum and XOR individually need to be zero, or if they should match the other group's values.", "5, Potential impossibility in constraints: The problem describes that the sum and the bitwise XOR of the integers in each group should be zero to find a solution. However, it seems mathematically improbable or extremely rare that both sums and XORs can uniformly be made zero simultaneously without extremely restrictive constraints on the input set, which hasn't been provided."]}}
{"task_id": "hard/6", "prompt": "def spaceship_command_sequence(grid, commands):\n    \"\"\"\n    In a universe where space travel is navigated through controlled grids and commands, there exists a grid system where each cell either contains a portal ('P'), a rock ('#'), or is empty ('.'). A spaceship starts at the top-left corner of the grid. Using a series of commands, the spaceship tries to move toward a portal to travel to a new dimension. The command sequence consists of 'U' (up), 'D' (down), 'L' (left), and 'R' (right).\n\n    Given a grid and a sequence of commands, write a function that returns the final position (as a tuple of coordinates) of the spaceship after the completion of the given command sequence. If the spaceship encounters a rock ('#'), it cannot proceed in that direction and thus stays in the current position. If it tries to move outside the grid boundaries or reaches a portal ('P'), the command sequence is halted immediately, and the current position is returned.\n\n    For example, consider the following grid and commands:\n    Grid:\n    [\n        ['.', '.', '.'],\n        ['.', '#', 'P'],\n        ['.', '.', '.']\n    ]\n    Commands: \"DRR\"\n\n    Starting from the top-left corner (0, 0), the spaceship would:\n    - Move down to (1, 0)\n    - Attempt to move right but encounters a rock at (1, 1), it remains at (1, 0)\n    - Moves right to (1, 2), encountering a portal, thus halting the command sequence.\n    The function should return (1, 2).\n\n    Note:\n    - The grid will have at least one row and one column.\n    - The spaceship always starts at the top-left corner (0, 0).\n    - The grid will always contain at least one portal.\n    - Commands end if the spaceship encounters a portal or an invalid move.\n    \n\"\"\"\n", "canonical_solution": "    def spaceship_command_sequence(grid, commands):\n        x, y = 0, 0  # Start position\n        max_rows = len(grid)\n        max_cols = len(grid[0])\n        direction_map = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n        for command in commands:\n            dx, dy = direction_map[command]\n            new_x = x + dx\n            new_y = y + dy\n            if 0 <= new_x < max_rows and 0 <= new_y < max_cols:\n                if grid[new_x][new_y] == '#':\n                    continue\n                if grid[new_x][new_y] == 'P':\n                    return (new_x, new_y)\n                x, y = new_x, new_y\n            else:\n                break\n        return (x, y)", "test": "def check(candidate):\n    grid1 = [['.', '.', '.'], ['.', '#', 'P'], ['.', '.', '.']]\n    commands1 = \"DRR\"\n    assert candidate(grid1, commands1) == (1, 2)\n\n    grid2 = [['.', '.', '.', '.'], ['.', '#', 'P', '.'], ['.', '.', '.', 'P']]\n    commands2 = \"DDRRUUL\"\n    assert candidate(grid2, commands2) == (1, 0)\n\n    grid3 = [['P', '#', '.'], ['.', '.', '.'], ['.', '.', '.']]\n    commands3 = \"RRD\"\n    assert candidate(grid3, commands3) == (0, 0)\n\n    grid4 = [['.', 'P'], ['.', '.']]\n    commands4 = \"R\"\n    assert candidate(grid4, commands4) == (0, 1)\n\n    grid5 = [['.', '.', '.', 'P'], ['.', '#', '.', '.'], ['.', '.', '.', '.']]\n    commands5 = \"RRRDD\"\n    assert candidate(grid5, commands5) == (0, 3)\n    grid6 = [['.', '.', '.', '.'], ['P', '.', '.', '.'], ['.', '.', '.', '.']]\n    commands6 = \"DL\"\n    assert candidate(grid6, commands6) == (1, 0)", "entry_point": "spaceship_command_sequence", "extra_info": {"cleaned_prompt": "Given a grid representing a space with empty cells ('.'), rocks ('#'), and portals ('P'), and a series of move commands ('U' for up, 'D' for down, 'L' for left, 'R' for right), compute the final position of a spaceship starting at the top-left corner after executing the commands. The sequence stops if the ship encounters a rock, moves outside the grid, or reaches a portal.", "cover_story_words": ["rocket", "portal"], "topics": ["Binary Tree", "Word Search"], "field": ["Reinforcement Learning"], "warnings": ["Solution failed correctness check. reason: failed: ", "4, Contradictory Instructions: The problem statement mentions that the command sequence ends whenever the spaceship encounters a rock ('#') or an invalid move, but the example \"DDRRUUL\" in the test cases suggests the spaceship can continue commands after stopping due to a rock. This contradiction between the description and provided example leads to ambiguity on how to correctly handle encountering a rock."]}}
{"task_id": "hard/1", "prompt": "def last_revealed_points(text, shrink_ray_sequences):\n    \"\"\"\n    In a tale of exploration, a team of adventurers discovers a lost city where they find an ancient device called the 'Shrink Ray'. The device has a sequence of commands that when executed can manipulate coordinates on a map of the lost city. The text variable represents a textual description of the city including its coordinates in (x, y) format scattered throughout the text. The shrink_ray_sequences is a series of operations that contain commands like 'select', 'remove', and 'convex_hull', applied to the coordinates found within the text. The team needs a program to evaluate the result of these operations to predict the final visible coordinates on the map after all commands from the shrink_ray_sequences have been processed.\n\n    The 'select' operation picks points that fulfill a specified condition (like 'x > 5'). The 'remove' operation deletes points. The 'convex_hull' operation applies the Graham's Scan algorithm to find the convex hull of the points, retaining only the points on the hull and any points inside the hull.\n\n    Example input text: 'The ancient city at (4, 3), once vibrant at (6, 7).'\n    Example operation sequence: [\n        {'operation': 'select', 'condition': 'x > 5'},\n        {'operation': 'convex_hull'},\n        {'operation': 'remove', 'condition': 'y < 7'}\n    ]\n\n    Output for this example should be {(6, 7)}, since after selecting points where x > 5, applying convex hull, and removing points where y < 7, the point (6, 7) remains.\n\n    Notes:\n    - Assume the input text strictly contains valid point representations.\n    - The sequence of operations in shrink_ray_sequences must be processed in the order they are provided.\n    \"\"\"", "entry_point": "last_revealed_points", "canonical_solution": "    import re\n    def parse_points(text):\n        return set(map(eval, re.findall('\\((\\d+),\\s*(\\d+)\\)', text)))\n\n    def last_revealed_points(text, shrink_ray_sequences):\n        points = parse_points(text)\n        for step in shrink_ray_sequences:\n            if step['operation'] == 'select':\n                points = {p for p in points if (lambda x, y: eval(step['condition']))(*p)}\n            elif step['operation'] == 'convex_hull':\n                points = convex_hull(points)\n            elif step['operation'] == 'remove':\n                points = {p for p in points if not (lambda x, y: eval(step['condition']))(*p)}\n        return points\n\n    def convex_hull(points):\n        # Implement actual Graham's scan algorithm for convex hull\n        if len(points) <= 1:\n            return set(points)\n        points = sorted(points, key=lambda p: (p[0], p[1]))\n        # Graham's scan part\n        return set(points  # Returned set of hull points)", "test": "def check(candidate):\n    assert candidate('The ancient city at (4, 3), once vibrant at (6, 7).', [{'operation': 'select', 'condition': 'x > 5'}, {'operation': 'convex_hull'}, {'operation': 'remove', 'condition': 'y < 7'}]) == {(6, 7)}\n    assert candidate('Coordinates scatter at (3, 5), near the temple at (8, 9), hidden path leads to (10, 2)', [{'operation': 'remove', 'condition': 'y < 6'}]) == {(8, 9)}\n    assert candidate('At edge of the forest (1, 1), a cave at (7, 7), river bend at (3, 4), monument stands at (9, 8)', [{'operation': 'convex_hull'}]) == set()\n    assert candidate('City center at (5, 5), outskirts at (2, 2), township at (5, 3)', []) == {(5, 5), (2, 2), (5, 3)}\n    assert candidate('Sparse remains at (0, 1), (2, 2), and lastly at (3, 3)', [{'operation': 'remove', 'condition': 'x < 3'}, {'operation': 'select', 'condition': 'y > 1'}]) == {(3, 3)}", "extra_info": {"cover_story_words": ["shrink ray", "lost city"], "topics": ["Graham's Scan", "Ordered Set"], "field": ["Natural Language Processing", "Geometric Algorithms"], "cleaned_prompt": "Write a function that takes a textual description of a city with coordinates and a sequence of commands that manipulate these coordinates. The function should return the remaining visible coordinates after all commands are processed. The commands include selecting points based on conditions, removing points based on conditions, and finding convex hulls of points.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 19)", "5, Ambiguous Operation Definition: The problem statement defines a 'convex_hull' operation with unclear behavior regarding points inside the hull. It's stated that after applying the convex hull, \"retaining only the points on the hull and any points inside the hull\", which contradicts typical convex hull operations that usually discard inner points. This ambiguity could lead to different interpretations and implementations, thereby affecting the output consistency across different solutions.", "5, Security Risk via eval(): The use of eval() for dynamic condition evaluation directly from user-supplied input (contained within 'shrink_ray_sequences') poses a severe security risk. It can potentially execute arbitrary and harmful code, which is particularly dangerous in a competitive programming or educational setup where multiple untrusted inputs might be evaluated.", "5, Incomplete Implementation Guidance: The provided canonical solution contains a placeholder comment \"# Implement actual Graham's scan algorithm for convex hull\" without an actual implementation of the Graham's Scan algorithm. This is crucial for solving the problem as the task relies heavily on correct and efficient computation of the convex hull. The lack of concrete implementation guidance or a provided method can result in many participants misunderstanding or failing to implement this significant portion of the task correctly."]}}
{"task_id": "hard/9", "prompt": "def friendly_ghost_game_connection(sport_events, distance_threshold):\n    \"\"\"\n    In a town, friendly ghosts enjoy a game at various sports events. They attempt to form connections based on the proximity of these events. A connection is valid if the distance between the two events is less than or equal to a specified distance threshold.\n\n    The objective is to compute the total number of valid connections that can be formed between these events. This problem introduces a graph-based approach to count these connections but not necessarily to form a Minimum Spanning Tree (MST).\n\n    Given a list of sport event coordinates (x, y) and a distance threshold, your task is to count the number of pairs of events that can be connected under the given distance threshold utilizing a graph processing approach which resembles Kruskal's algorithm in the edge processing method, but the focus is on counting edge pairs rather than constructing an MST.\n\n    Example:\n    Input: sport_events = [(0, 0), (3, 4), (6, 8), (10, 12)], distance_threshold = 5\n    Output: 2\n\n    Explanation:\n    The distances:\n    Between (0, 0) and (3, 4) is 5 (can connect)\n    Between (3, 4) and (6, 8) is 5 (can connect)\n    Other pair distances exceed 5 (cannot connect)\n    Thus, the count of valid connections is 2.\n    \"\"\"\n", "canonical_solution": "    from math import sqrt\n\n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def count_connections(points, max_dist):\n        edges = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = distance(points[i], points[j])\n                if dist <= max_dist:\n                    edges.append((dist, i, j))\n        edges.sort()\n\n        connection_count = 0\n        seen = set()\n        for dist, u, v in edges:\n            if (u, v) not in seen and (v, u) not in seen:\n                seen.add((u, v))\n                connection_count += 1\n        return connection_count\n\n    return count_connections(sport_events, distance_threshold)", "test": "def check(candidate):\n    assert candidate([(0, 0), (3, 4), (6, 8), (10, 12)], 5) == 2\n    assert candidate([(0, 0), (2, 2), (5, 5)], 3) == 1\n    assert candidate([(1, 1), (4, 5), (9, 9), (13, 14)], 5) == 2\n    assert candidate([(0, 0)], 1000) == 0\n    assert candidate([(1, 2), (3, 4), (5, 6), (7, 8), (10, 12)], 2) == 0\n    assert candidate([], 10) == 0", "entry_point": "friendly_ghost_game_connection", "extra_info": {"cover_story_words": ["friendly ghosts", "sports"], "topics": ["Counting", "Graph Processing"], "field": ["Internet of Things (IoT)"], "cleaned_prompt": "Define a function that calculates the number of valid connections that can be formed between a list of sports event coordinates, where a connection is valid if the distance between events is less than or equal to a given threshold. The counting should be done through a method that processes edges similar to Kruskal\u2019s algorithm, focusing on connection counting. Example: Input: sport_events = [(0, 0), (3, 4), (6, 8), (10, 12)], distance_threshold = 5 Output: 2", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Unclear Problem Statement: The problem statement mentions utilizing a Kruskal algorithm-like edge processing method but does not clearly define how this method should be applied to counting connections, rather than constructing an MST. This lack of specificity may confuse participants about the expected algorithmic approach, especially since Kruskal's algorithm is generally used for MST construction, not for counting edge pairs.", "4, Ambiguity in Efficiency Requirements: The problem description does not specify any efficiency or time complexity requirements. Given that the naive implementation involves checking all possible pairs of points, which can be computationally expensive for large inputs, clearer guidelines or limits on input sizes should be provided to ensure feasible solutions within typical competition time frames."]}}
{"task_id": "hard/3", "prompt": "def enchanted_sudoku_solver(puzzle, enchanted_mask):\n    \"\"\"\n    Solve an 'Enchanted Sudoku' puzzle where:\n    - Each row, column, and 3x3 sub-grid must contain the digits 1-9 with no repetition.\n    - Specific cells, marked by a corresponding bitmask (1 denotes enchanted, 0 denotes normal), need to fulfill additional conditions if they are enchanted:\n       * The sum of the enchanted cells in any row, column, or 3x3 sub-grid must total 15, if there are exactly three enchanted cells in that row, column or sub-grid.\n       * If there are less than three or more than three enchanted cells in a row, column or sub-grid, they do not need to satisfy the sum of 15 condition.\n\n    The task is to complete the Sudoku puzzle respecting both the usual Sudoku rules and the enchanted cell constraints.\n    \"\"\"", "canonical_solution": "    from functools import lru_cache\n\n    def is_valid(x, y, val, sudoku, bitmask):\n        block_x, block_y = 3 * (x // 3), 3 * (y // 3)\n        for i in range(9):\n            if sudoku[x][i] == val or sudoku[i][y] == val or sudoku[block_x + i // 3][block_y + i % 3] == val:\n                return False\n\n        if bitmask[x][y] == 1:\n            enchanted_sum = 0\n            enchanted_count = 0\n            for i in range(9):\n                if bitmask[x][i] == 1:\n                    enchanted_sum += sudoku[x][i]\n                    enchanted_count += 1\n                if bitmask[i][y] == 1:\n                    enchanted_sum += sudoku[i][y]\n                    enchanted_count += 1\n                if bitmask[block_x + i // 3][block_y + i % 3] == 1:\n                    enchanted_sum += sudoku[block_x + i // 3][block_y + i % 3]\n                    enchanted_count += 1\n            if enchanted_count == 3 and enchanted_sum != 15:\n                return False\n\n        return True\n\n    @lru_cache(None)\n    def solve_sudoku(cell=0):\n        if cell == 81:\n            return True\n        x, y = divmod(cell, 9)\n        if sudoku[x][y] != 0:\n            return solve_sudoku(cell + 1)\n        for num in range(1, 10):\n            if is_valid(x, y, num, sudoku, bitmask):\n                sudoku[x][y] = num\n                if solve_sudoku(cell + 1):\n                    return True\n                sudoku[x][y] = 0\n\n        return False\n\n    sudoku, bitmask = puzzle.copy(), enchanted_mask.copy()\n    if solve_sudoku():\n        return sudoku\n    else:\n        return None", "test": "def check(candidate):\n    assert candidate([[0]*9 for _ in range(9)], [[0]*9 for _ in range(9)]) == None,\n    assert candidate([[0]*9 for _ in range(9)], [[1]*9 for _ in range(9)]) == None,\n    assert candidate([[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7]], [[1]*9 for _ in range(3)]) == None,\n    assert candidate([[0]*9 for _ in range(9)], [[0]*9 for _ in range(9)]) == None,\n    assert candidate([[0]*9 for _ in range(9)], [[0]*9 for _ in range(9)]) == None\n\n    print(\"All test cases pass\")", "entry_point": "enchanted_sudoku_solver", "extra_info": {"cover_story_words": ["spaceship", "enchanted"], "topics": ["Bitmask", "Sudoku Solver"], "field": ["Computer Science"], "cleaned_prompt": "def enchanted_sudoku_solver(puzzle, enchanted_mask):\n    Solve an 'Enchanted Sudoku' puzzle considering the standard Sudoku rules and additional enchanted cells rules. Enchanted cells in groups of exactly three must together add up to 15. The function takes as inputs a 9x9 Sudoku grid 'puzzle' and a 9x9 binary grid 'enchanted_mask' where 1 denotes an enchanted cell and 0 denotes a normal cell.\n    Example usage is shown below.", "warnings": ["Solution failed correctness check. reason: failed: invalid syntax (<string>, line 10)", "5, Incomplete function implementation: The canonical_solution provided for the enchanted_sudoku_solver function does not handle resetting the enchanted_sum and enchanted_count properly within blocks and rows/columns. This can lead to inaccurate counting and summing of enchanted cells, making the function unreliable for determining if the enchanted cell conditions are met.", "5, Logical flaw in is_valid function: The is_valid function updates the enchanted_sum and enchanted_count for a row, column, and block without taking into account only the cells filled so far. It should only update these based on already filled cells rather than including zeros, which represent unfilled cells in Sudoku.", "4, Canonical solution inefficiency: The canonical_solution seems to lack optimization for backtracking, potentially leading to high computational time, especially without efficient pruning when invalid conditions are detected early."]}}
{"task_id": "hard/8", "prompt": "def rocket_optimal_launch_schedule(intervals):\n    \"\"\"\n    Manage a streamlined rocket launch scheduling by determining the most efficient times to launch rockets. This means finding the maximum number of rockets that can be launched within their scheduled intervals without any overlap.\n\n    Each rocket's available launch window is defined by an interval [start, end), where 'start' is the inclusive starting time, and 'end' is the exclusive ending time. No two rockets can launch if their designated intervals overlap.\n\n    Given a list of intervals (each representing a rocket's launch window), your task is to compute the maximum number of rockets you can launch such that their intervals do not overlap.\n\n    Example:\n    Input: intervals = [[1,3], [2,4], [3,5]]\n    Output: 2\n    Explanation: Schedules for launching rockets in intervals [1,3] and [3,5] can be arranged without overlapping, however [1,3] and [2,4] do overlap.\n\n    Another example:\n    Input: intervals = [[6,8], [9,10], [1,3]]\n    Output: 3\n    Explanation: All intervals are non-overlapping, enabling the launch of all rockets within their designated windows.\n    \"\"\"\n", "canonical_solution": "    intervals.sort(key=lambda x: x[1])\n    count = 0\n    last_end = -1\n    for start, end in intervals:\n        if start >= last_end:\n            count += 1\n            last_end = end\n    return count", "test": "def check(candidate):\n    assert candidate([[1, 3], [2, 4], [3, 5]]) == 2\n    assert candidate([[6, 8], [9, 10], [1, 3]]) == 3\n    assert candidate([[7, 8], [8, 9], [9, 10], [6, 7]]) == 4\n    assert candidate([[5, 10], [10, 15]]) == 2\n    assert candidate([]) == 0\n    assert candidate([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10]]) == 10", "entry_point": "rocket_optimal_launch_schedule", "extra_info": {"cover_story_words": ["rocket"], "topics": ["Greedy Algorithms", "Interval Scheduling"], "field": "Operations Research", "cleaned_prompt": "Write a function that determines the maximum number of non-overlapping intervals from a list of intervals. Each interval [start, end) represents a launch window for a rocket, where 'start' is inclusive and 'end' is exclusive. Return the maximum number of non-overlapping intervals. \n\nExample:\nInput: [[1,3], [2,4], [3,5]]\nOutput: 2", "warnings": ["5, Canonical Solution Incorrect Handling of Input Edge Cases: The canonical solution provided does not handle cases where the list of intervals may contain tuples of non-integer values, intervals that are not properly formatted (e.g., if an interval does not contain two elements), or intervals where the 'start' time is after the 'end' time, which could lead to unexpected behavior or runtime errors. Such issues should be covered in a robust solution or at least noted in the problem statement to ensure that inputs are well-formed.", "4, Inadequate Problem Constraints: The problem does not define the size constraints for the interval list or the range of the integers that could possibly be an element of the intervals. Without these constraints, it's challenging to gauge the efficiency requirements of the solution and to understand what kind of edge cases need consideration (e.g., extremely large numbers, very large lists)."]}}
