{"task_id": "hard/6", "prompt": "def max_path_sum(grid):\n    \"\"\"\n    Given a matrix of integers representing a grid, start at the top-left corner and find a path to the bottom-right corner which maximizes the sum of integers in the path. You may only move down or right at any step.\n\n    For example, if the grid is:\n        [\n         [1, 3, 1],\n         [1, 5, 1],\n         [4, 2, 1]\n        ]\nThe output should be 12 because the maximum sum path is from the top-left corner 1 -> 3 -> 5 -> 2 -> 1, which results in the sum of 1+3+5+2+1 = 12.\n\n    Note:\n    - The grid size will be at least 1x1.\n    - All numbers in the grid will be integers.\n    \"\"\"\n", "canonical_solution": "    def max_path_sum(grid):\n        n = len(grid)\n        m = len(grid[0])\n        for i in range(1, n):\n            grid[i][0] += grid[i-1][0]\n        for j in range(1, m):\n            grid[0][j] += grid[0][j-1]\n        for i in range(1, n):\n            for j in range(1, m):\n                grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]", "test": "def check(candidate):\n    assert candidate([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12\n    assert candidate([[1]]) == 1\n    assert candidate([[1, 3, 1], [1, 5, 1]]) == 10\n    assert candidate([[2], [3], [5]]) == 10\n    assert candidate([[1, 2, 3, 0], [0, 0, 0, 10], [9, 8, 7, 6]]) == 27", "entry_point": "max_path_sum", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Write a function 'max_path_sum(grid)' that computes the maximum sum of a path from the top-left corner to the bottom-right corner in a grid where moves are restricted to right and down. The function input 'grid' is a 2D matrix of integers.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Problem description contradiction: The prompt example path is incorrect based on the provided logic. The prompt suggests moving from the top-left to the bottom-right using the path 1 -> 3 -> 5 -> 2 -> 1, leading to a sum path of 13 (not 12 as stated). Yet, the problem statement states that paths can only move right or down, hence a correct path according to this rule (assuming no skipping) should be 1 -> 3 -> 1 -> 5 -> 1 -> 1 for a sum of 12. However, the stated path yields a sum of 13 instead. There's a computation error or a misunderstanding of how the path is described or calculated. This could confuse the participants about the rules or methods to find the path."]}}
{"task_id": "hard/9", "prompt": "def longest_unique_subsequence(arr):\n    \"\"\"\n    Write a function longest_unique_subsequence that takes a list of integers `arr` and finds the longest contiguous subsequence of the list such that all numbers in that subsequence are unique. A subsequence here refers to a sequence that can be derived from the list by deleting some or no elements without changing the order of the remaining elements.\n\n    The function should return the length of the longest contiguous unique subsequence.\n\n    If the list is empty, the function should return 0.\n\n    Examples:\n    - longest_unique_subsequence([4, 3, 5, 2, 4, 5, 3]) should return 4 (possible subsequence is [4, 3, 5, 2]).\n    - longest_unique_subsequence([1, 1, 1]) should return 1 (only one unique number). \n    - longest_unique_subsequence([]) should return 0.\n\n    Notes:\n    - The input will not contain any elements other than integers.\n    \"\"\"\n", "canonical_solution": "    unique_counter = {}\n    max_length = 0\n    l_index = 0\n    for r_index, num in enumerate(arr):\n        if num in unique_counter and unique_counter[num] >= l_index:\n            l_index = unique_counter[num] + 1\n        unique_counter[num] = r_index\n        max_length = max(max_length, r_index - l_index + 1)\n    return max_length", "test": "def check(candidate):\n    assert candidate([4, 3, 5, 2, 4, 5, 3]) == 4\n    assert candidate([1, 1, 1]) == 1\n    assert candidate([3, 5, 3, 2, 5]) == 4\n    assert candidate([]) == 0\n    assert candidate([0, 1, 2, 3, 4, 5]) == 6\n    assert candidate([9, 9, 9, 7, 9, 8, 9]) == 3", "entry_point": "longest_unique_subsequence", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Create a function that takes a list of integers and returns the length of the longest contiguous subsequence where all numbers are unique. The sequence should be derived by keeping the order intact while possibly removing elements.\n\nExamples:\nlongest_unique_subsequence([4, 3, 5, 2, 4, 5, 3]) should return 4.\nlongest_unique_subsequence([1, 1, 1]) should return 1.\nlongest_unique_subsequence([]) should return 0.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Incorrect terminology: The problem statement incorrectly uses the term \"subsequence.\" A subsequence can have non-consecutive elements from the list, which contradicts the requirement for the elements to be contiguous. The correct term should be \"subarray\" or \"contiguous subsegment.\"", "4, Unclear edge case handling: The explanation on how to handle potential negative numbers, maximum array sizes, or performance implications on very large arrays is missing. This can lead to inefficient solutions or unexpected errors in certain edge cases."]}}
{"task_id": "hard/4", "prompt": "def unique_substring_pairs(s, k):\n    \"\"\"\n    Given a string `s` and an integer `k`, write a function that returns the number of unique pairs of substrings of `s` that are of length `k` and are anagrams of each other.\n\n    A substring is a contiguous sequence of characters within a string. Anagrams are two strings that can be rearranged to form each other.\n\n    Example:\n        s = 'abba', k = 2 -> Possible pairs: ('ab', 'ba'), ('bb', 'bb'), so the output should be 2. \n        s = 'abcd', k = 2 -> No two substrings of length 2 are anagrams of each other, output should be 0.\n        s = 'ifailuhkqq', k = 2 -> Possible pairs: ('if', 'fi'), ('fa', 'af'), ('iu', 'ui'), ('il', 'li'), ('uh', 'hu'), ('hk', 'kh'), ('kq', 'qk'); output should be 7.\n    \"\"\"\n", "canonical_solution": "    from collections import Counter\n    def substrings(s, k):\n        for i in range(len(s) - k + 1):\n            yield s[i:i+k]\n\n    def is_anagram(s1, s2):\n        return Counter(s1) == Counter(s2)\n\n    count = 0\n    sub = list(substrings(s, k))\n    visited = set()\n    for i in range(len(sub)):\n        for j in range(i + 1, len(sub)):\n            if is_anagram(sub[i], sub[j]) and (sub[i], sub[j]) not in visited and (sub[j], sub[i]) not in visited:\n                visited.add((sub[i], sub[j]))\n                count += 1\n    return count", "test": "def check(candidate):\n    assert candidate('abba', 2) == 2\n    assert candidate('abcd', 2) == 0\n    assert candidate('ifailuhkqq', 2) == 7\n    assert candidate('aaaaaaaaaa', 2) == 45\n    assert candidate('xyzxyz', 3) == 1", "entry_point": "unique_substring_pairs", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Given a string `s` and an integer `k`, return the number of unique pairs of substrings of `s` that are of length `k` and are anagrams of each other. Examples: s = 'abba', k = 2 -> 2; s = 'abcd', k = 2 -> 0; s = 'ifailuhkqq', k = 2 -> 7.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Problem Definition Error: The example given in the prompt `s = 'ifailuhkqq', k = 2 -> Possible pairs: ('if', 'fi'), ('fa', 'af'), ('iu', 'ui'), ('il', 'li'), ('uh', 'hu'), ('hk', 'kh'), ('kq', 'qk'); output should be 7.` is incorrect. For the string 'ifailuhkqq' and k = 2, possible pairs of anagrams of substrings should be fewer as many pairs listed do not appear in the string itself, such as ('fi'), being a reordering and not an actual substring found independently in the input string.", "5, Algorithm Inefficiency: The provided canonical solution has a highly inefficient checking method for counting anagram pairs, using nested loops and generating all substring combinations, then comparing each combination if they are anagrams. This method leads to excessive computational complexity, potentially O(n^4) for large inputs, making it impractical for larger strings and k values.", "4, Inaccurate Testing: The test cases in the `check` function presume the functionality based on the incorrect example explained in the problem statement (`s = 'ifailuhkqq', k = 2` expected result 7), which could lead to false positive testing and doesn't accurately validate the solution to the problem description."]}}
{"task_id": "hard/8", "prompt": "def find_rare_operations(expression, operations):\n    \"\"\"\n    Given a mathematical expression as a string and a list of rare operations as strings, your task is to return a list of all the rare operations found in the expression in the order they appear.\n\n    - The expression will only contain characters in [0-9], [a-zA-Z], and common operators (+, -, *, /).\n    - Rare operations are given as subsets of characters that denote custom operations not typically found in standard arithmetic expressions.\n    - The match must be exact and not a subset of a larger segment that includes numbers or letters.\n    - If no rare operations are found, return an empty list.\n    - Operations appearing more than once in the expression should be listed each time they appear.\n\n    Examples:\n    find_rare_operations('12abc34def55abc9x', ['abc', 'def', 'xx']) returns ['abc', 'def', 'abc']\n    find_rare_operations('235+678', ['**', '^^']) returns []\n    find_rare_operations('100%%%20^2###3', ['%%', '^', '###']) returns ['%%', '^', '###']\n    \"\"\"\n", "canonical_solution": "    import re\n    def find_rare_operations(expression, operations):\n        pattern = '|'.join(map(re.escape, operations))\n        matches = re.findall(pattern, expression)\n        return matches", "test": "def check(candidate):\n    assert candidate('12abc34def55abc9x', ['abc', 'def', 'xx']) == ['abc', 'def', 'abc']\n    assert candidate('235+678', ['**', '^^']) == []\n    assert candidate('100%%%20^2###3', ['%%', '^', '###']) == ['%%', '^', '###']\n    assert candidate('88&&&87**&&', ['&&&', '**']) == ['&&&', '**']\n    assert candidate('no operations here', ['!', '@', '#']) == []\n    assert candidate('', ['abc', 'def']) == []", "entry_point": "find_rare_operations", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Find all rare operations from a list in the given expression string. Each instance should be returned in the order of appearance. Rare operations are exact matches outside typical numeric values and common operators. Return an empty list if none or not found.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Ambiguity in Definition of Rare Operations: The problem statement does not explicitly clarify what constitutes a rare operation other than saying it is not a standard arithmetic operation. This ambiguity can lead to confusion about what characters or patterns enforce a match as a \"rare operation.\" Clear specifications or inclusion of edge examples could help, especially when operations contain alphanumeric characters.", "5, Unclear Matching Requirements: The prompt states that matches must be exact and not part of larger segments including numbers or letters, but the canonical solution simply uses regex findall without ensuring this condition. This misalignment between the problem description and the provided solution can result in incorrect findings where the operation is a subset of a larger alphanumeric string, which is contrary to the requirements.", "4, Overlap and Repetition Handling: The provided solution and prompt do not address scenarios where rare operations might overlap in the expression or how to handle repeated operations particularly when they interweave (e.g., '&&&&' for '&&'). This could lead to unexpected behavior or incorrect outputs if rare operations can overlap in various complex ways."]}}
{"task_id": "hard/10", "prompt": "def ascii_art_symmetry(art):\n    \"\"\"\n    Given a list of strings representing an ASCII art (where each string is a line of the art), determine if this art is horizontally symmetric, vertically symmetric, or both.\n\n    Example 1: For the art represented by ['****', '*  *', '****'], the function should return 'Both' because it is symmetric both horizontally and vertically.\n\n    Example 2: For the art represented by ['****', '*  *', '*  *', '****'], the function should return 'Vertical' because it is only symmetric vertically.\n\n    Example 3: For the art represented by ['****', '****', '****', '****'], the function should return 'Horizontal' because it is only symmetric horizontally since all lines are the same.\n\n    Example 4: For the art represented by ['****', '*  *', '*** '], the function should return 'Neither' because it is neither horizontally nor vertically symmetric.\n    \"\"\"\n", "canonical_solution": "    def is_horizontal_symmetric(art):\n        return all(line == line[::-1] for line in art)\n\n    def is_vertical_symmetric(art):\n        return art == art[::-1]\n\n    horizontal_symmetric = is_horizontal_symmetric(art)\n    vertical_symmetric = is_vertical_symmetric(art)\n\n    if horizontal_symmetric and vertical_symmetric:\n        return 'Both'\n    elif horizontal_symmetric:\n        return 'Horizontal'\n    elif vertical_symmetric:\n        return 'Vertical'\n    else:\n        return 'Neither'", "test": "def check(candidate):\n    assert candidate(['****', '*  *', '****']) == 'Both'\n    assert candidate(['****', '*  *', '*  *', '****']) == 'Vertical'\n    assert candidate(['****', '****', '****', '****']) == 'Horizontal'\n    assert candidate(['****', '*  *', '*** ']) == 'Neither'\n    assert candidate(['****', '* *', '****']) == 'Neither'\n    assert candidate(['    ', '    ', '    ', '    ']) == 'Both'\n    assert candidate(['*  *', ' * *', '*  *']) == 'Both'\n    assert candidate(['* * ', ' ** ', '* * ']) == 'Horizontal'", "entry_point": "ascii_art_symmetry", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Given a list of strings representing an ASCII art, determine its symmetry type: 'Both' (horizontally and vertically symmetric), 'Horizontal', 'Vertical', or 'Neither'.\nExamples:\n['****', '*  *', '****'] -> 'Both'\n['****', '*  *', '*  *', '****'] -> 'Vertical'\n['****', '****', '****', '****'] -> 'Horizontal'\n['****', '*  *', '*** '] -> 'Neither'", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Inconsistent definitions: The explanation and examples provided give contradictory definitions of horizontal and vertical symmetry. For instance, the example of ['****', '****', '****', '****'] is deemed 'Horizontal', but based on the given functions, it should also be 'Vertical', as all lines are identical when reflected or reversed. This inconsistency makes the prompt problematic for accurately assessing solutions.", "5, Unclear prompt language: The definitions of \"horizontally symmetric\" and \"vertically symmetric\" are not clear from the prompt alone without reviewing the solution. This lack of clarity can lead to confusion about what constitutes horizontal versus vertical symmetry, especially for participants who might interpret these terms differently.", "4, Incorrect example outputs: The example ['* * ', ' ** ', '* * '] provided in the tests is said to be 'Horizontal' symmetric, however, this is incorrect as none of the lines are symmetric when reversed, nor does the ASCII art look symmetric horizontally. This example can mislead participants about the expected behavior."]}}
{"task_id": "hard/5", "prompt": "def sort_by_frequency_and_value(arr):\n    \"\"\"\n    Write a function that takes a list of integers and sorts them based on the frequency of their occurrence in ascending order and by their value in descending order within the same frequency.\n\n    For example, if the input is [4, 5, 6, 5, 4, 3], the output should be [3, 6, 5, 5, 4, 4] because:\n    - Number 3 and 6 occur once, sort them descending as [6, 3], then place them because of ascending order of frequency.\n    - Number 5 occurs twice, and so does 4, but since we need descending order in the same frequency, the highest value (5) comes before 4.\n    \n    Note:\n    - The input list is not guaranteed to be sorted in any order.\n    - If all numbers occur with the same frequency, the output list should be sorted in descending order.\n    - The function should be able to handle an empty list, returning an empty list in this case.\n    \"\"\"\n", "canonical_solution": "    from collections import Counter\n    def sort_by_frequency_and_value(arr):\n        freq = Counter(arr)\n        return sorted(arr, key=lambda x: (freq[x], -x))", "test": "def check(candidate):\n    assert candidate([4, 5, 6, 5, 4, 3]) == [3, 6, 5, 5, 4, 4]\n    assert candidate([]) == []\n    assert candidate([1, 2, 2, 3, 3, 3]) == [1, 2, 2, 3, 3, 3]\n    assert candidate([7, 6, 5, 5, 5, 8, 8]) == [6, 7, 8, 8, 5, 5, 5]\n    assert candidate([9]) == [9]", "entry_point": "sort_by_frequency_and_value", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Sort a list of integers based on the frequency of their occurrence in ascending order and by their value in descending order within the same frequency. Given a list of integers, sort and return the list accordingly. Ensure the function handles empty lists by returning an empty list.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Sort Direction Conflict: The description specifies that the list should be sorted by frequency in \"ascending order\", yet the sorting within the same frequency should be by value in \"descending order\". However, the provided canonical solution sorts the entire list primarily by frequency in ascending order but then uses the value negatively without distinguishing whether they belong to the same frequency group or not. This will incorrectly prioritize higher values even possibly outside their frequency groups over higher frequencies. Sorting needs careful segregation between frequency grouping and value ordering within those groups.", "4, Ambiguity in requirements: The problem statement needs to clarify the behavior when two numbers with different frequencies are compared. The phrase \"sort them based on the frequency of their occurrence in ascending order\" should explicitly state that when two numbers have the same value but different frequencies, those with lower frequencies should come first."]}}
{"task_id": "hard/3", "prompt": "def fourier_transform_frequency_dominant(input_signal):\n    \"\"\"\n    Write a function that takes a list of real numbers representing an input signal in the time domain and returns the predominant frequency in the signal using the Fourier Transform.\n\n    For example:\n    - If the input_signal is [1, 0, -1, 0], the function should return 1.0 as the frequency since it's a basic sine wave at 1 Hz.\n    - For input_signal [0, 1, 0, -1], which is a shift of the previous example, should still return 1.0 as the fundamental frequency does not change with phase shifts.\n    \n    The frequencies are derived from the indices of the discrete Fourier Transform results, and the frequency with the largest magnitude (ignoring the DC component) is considered predominant.\n    \n    Note: Use the numpy or equivalent library for computing FFT and assume that the length of the input_signal is always a power of two for simplicity.\n    \"\"\"\n", "canonical_solution": "    import numpy as np\n    def fourier_transform_frequency_dominant(input_signal):\n        fft_result = np.fft.fft(input_signal)\n        freq_indices = np.fft.fftfreq(len(input_signal))\n        # Eliminate the zero frequency component (DC component)\n        fft_result[0] = 0\n        dominant_index = np.argmax(np.abs(fft_result))\n        return np.abs(freq_indices[dominant_index])", "test": "def check(candidate):\n    assert abs(candidate([1, 0, -1, 0]) - 1.0) < 1e-6\n    assert abs(candidate([0, 1, 0, -1]) - 1.0) < 1e-6\n    assert abs(candidate([1, 1, 1, 1, 0, 0, 0, 0]) - 0.25) < 1e-6\n    assert abs(candidate([0, 1]) - 0.5) < 1e-6\n    assert abs(candidate([np.sin(2 * np.pi * 2 * t / 8) for t in range(8)]) - 2.0) < 1e-6", "entry_point": "fourier_transform_frequency_dominant", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Write a function that takes a list of real numbers representing a signal in time domain and returns the predominant frequency using Fourier Transform. Ignore the zero frequency component in the FFT result. Assume the length of the input list is a power of two.", "warnings": ["Solution failed correctness check. reason: failed: 'NoneType' object is not callable", "5, Unclear sampling rate: The problem does not specify the sampling rate of the input signal, which is crucial to accurately calculate the frequency in Hz. The frequency calculation directly depends on both the length of the signal and its sampling rate. Without this information, the frequency values calculated may not correspond to real-world units (Hz).", "4, Missing validation for power of two: While the prompt mentions to assume that the length of the input signal is always a power of two, there is no validation check in the code to ensure this condition. This could lead to unexpected behaviors or errors if non-compliant data is inadvertently processed."]}}
{"task_id": "hard/2", "prompt": "def rotate_and_multiply(matrix, k):\n    \"\"\"\n    Given a square matrix (2D list) of integers and a positive integer k, rotate the matrix k times clockwise and then multiply all rotated matrix elements by k.\n\n    For example:\n    If matrix = [[1, 2], [3, 4]] and k = 2,\n    After 2 rotations, the matrix would be [[1, 2], [3, 4]] (as each 4 rotations bring it back to original).\n    Then, multiplying each element by 2, the resultant matrix would be [[2, 4], [6, 8]].\n\n    Note:\n    - Rotating the matrix once clockwise entails moving each element to its right position with corners cycling around.\n    - matrix will be a non-empty square matrix.\n\n    Example of a single rotation for a 3x3 matrix:\n    Starting from matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    After one clockwise rotation, it becomes: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n", "canonical_solution": "    def rotate(matrix):\n        return [list(reversed(col)) for col in zip(*matrix)]\n    for _ in range(k % 4):\n        matrix = rotate(matrix)\n    return [[element * k for element in row] for row in matrix]", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4]], 2) == [[2, 4], [6, 8]]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    assert candidate([[1]], 3) == [[3]]\n    assert candidate([[1, 2], [3, 4]], 4) == [[1, 2], [3, 4]]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [[7 * 3, 4 * 3, 1 * 3], [8 * 3, 5 * 3, 2 * 3], [9 * 3, 6 * 3, 3 * 3]]", "entry_point": "rotate_and_multiply", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Write a function that given a square matrix and an integer k, rotates the matrix k times clockwise and then multiplies each element by k.\n\nExamples:\n- For matrix = [[1, 2], [3, 4]] and k = 2, the output should be [[2, 4], [6, 8]].\n- For each rotation of a 3x3 matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]], it transforms to [[7, 4, 1], [8, 5, 2], [9, 6, 3]].", "warnings": ["Solution failed correctness check. reason: failed: ", "4, Solution Format Mismatch: The canonical solution provided is defined with an incorrect structure that does not fit into the `rotate_and_multiply` function format as specified in the prompt. The solution is written outside of the function body and there is no clear function definition which follows the requested function signature `def rotate_and_multiply(matrix, k):`.", "5, Incorrect Test Case Handling: The test cases in `check` function are incorrectly structured because they use assertions that expect the function `candidate` but the prompt's main function is `rotate_and_multiply`. This inconsistency can lead to confusion and errors when running the given tests in a real coding environment."]}}
{"task_id": "hard/7", "prompt": "def max_product_triangle(matrix):\n    \"\"\"\n    Given a square matrix (2D list) of integers, find the maximum product of any triangle in the grid. A triangle in this context is defined by three points that form a triangle shape by connecting directly adjacent (horizontally, vertically, or diagonally)\n\n    Examples:\n    - For matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], the maximum product triangle is formed by the points with values (5, 3, 9), and the product is 5 * 3 * 9 = 135.\n    - For matrix = [[-1, -2, 3], [3, 5, -1], [0, 2, -4]], the maximum product triangle is formed by the points (5, 3, 2) with a product of 5 * 3 * 2 = 30.\n\n    Notes:\n    - The matrix will always be of size at least 2x2.\n    - The matrix can contain both positive, zero, and negative numbers.\n    \"\"\"\n", "canonical_solution": "\tdef max_product_triangle(matrix):\n\t    from itertools import combinations\n\t    n = len(matrix)\n\t    max_product = float('-inf')\n\t    def product(p):\n\t        return matrix[p[0][0]][p[0][1]] * matrix[p[1][0]][p[1][1]] * matrix[p[2][0]][p[2][1]]\n\t    for the three points in combinations([(i, j) for i in range(n) for j in range(n)], 3):\n\t        current_product = product(three points)\n\t        if current_product > max_product:\n\t            max_product = current_product\n\t    return max_product", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 135\n    assert candidate([[-1, -2, 3], [3, 5, -1], [0, 2, -4]]) == 30\n    assert candidate([[0, 2], [9, 3]]) == 0\n    assert candidate([[-1, 1], [-1, -1]]) == -1\n    assert candidate([[4, 1], [2, 4]]) == 16", "entry_point": "max_product_triangle", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "Given a square matrix of integers, find the maximum product of any triangle formed by adjacent points (horizontally, vertically, or diagonally).\n\nExamples:\n- matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], the maximum product triangle is (5, 3, 9) -> product: 135.\n- matrix = [[-1, -2, 3], [3, 5, -1], [0, 2, -4]], the maximum product triangle is (5, 3, 2) -> product: 30.", "warnings": ["Solution failed correctness check. reason: failed: inconsistent use of tabs and spaces in indentation (<string>, line 13)", "5, Incorrect definition of adjacency: The problem statement mentions that triangles can be formed by connecting points that are directly adjacent, including diagonally. However, the provided examples involve combinations where the points are not strictly adjacent. This confuses the definition of what an \"adjacent triangle\" means in terms of grid connectivity.", "4, Logical flaw in examples: The matrix examples provided and their corresponding solutions don't adhere to the stated adjacency rule. In the examples, points used are not adjacent by any standard grid adjacency rules, leading to confusion about what constitutes a valid triangle."]}}
{"task_id": "hard/1", "prompt": "def treasure_hunt(matrix):\n    \"\"\"\n    You are given a 2D matrix where each cell contains an integer. The goal is to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (len(matrix)-1, len(matrix[0])-1), where the difference in value between two consecutive cells is minimal.\n\n    The path can only move either right or down at each step. The score of a path is determined by the maximum difference in values between any two consecutive cells along the path.\n\n    Write a function that returns the minimum score of all possible paths from the top-left corner to the bottom-right corner.\n\n    Example Input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n    \nThe function should return 1, because the path 1 -> 2 -> 3 -> 6 -> 9 has the minimal maximum difference in values between consecutive cells.\n\n    Example:\n    Input: [[3, 10, 6], [9, 7, 3], [0, 5, 8]]\n    Output: 5 (One minimal path is: 3 -> 9 -> 7 -> 5 -> 8 with maximum consecutive difference of 5 between 9 and 7)\n    \"\"\"\n", "canonical_solution": "    from heapq import heappop, heappush\n    def treasure_hunt(matrix):\n        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        heap = [(0, 0, 0)]\n        while heap:\n            score, x, y = heappop(heap)\n            for dx, dy in ((1, 0), (0, 1)):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    next_score = max(score, abs(matrix[nx][ny] - matrix[x][y]))\n                    if next_score < dp[nx][ny]:\n                        dp[nx][ny] = next_score\n                        heappush(heap, (next_score, nx, ny))\n        return dp[m-1][n-1]", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 1\n    assert candidate([[3, 10, 6], [9, 7, 3], [0, 5, 8]]) == 5\n    assert candidate([[0]]) == 0\n    assert candidate([[1, 100], [1000, 1001]]) == 1\n    assert candidate([[100, 300, 200], [600, 400, 500], [300, 200, 100]]) == 200\n    assert candidate([[5, 4], [3, 2]]) == 1", "entry_point": "treasure_hunt", "extra_info": {"cover_story_words": [], "topics": [], "field": "", "cleaned_prompt": "You are given a 2D matrix of integers. Find the shortest path from the top-left to the bottom-right corner that minimizes the maximum difference in value between two consecutive cells, only moving right or down. Return this minimum possible maximum difference. Example: For matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]], the function should return 1, as the best path is 1 -> 2 -> 3 -> 6 -> 9 with a maximal consecutive difference of 1.", "warnings": ["Solution failed correctness check. reason: failed: ", "5, Undefined Behavior for Empty Matrices: The function description and prompt do not specify the expected behavior when the input matrix is empty either by being an empty list or having empty sublists. This can lead to undefined or erroneous behavior if not handled properly in the implementation.", "5, Inadequate Handling of Non-Rectangular Matrices: The problem statement does not specify whether the input matrix will always be rectangular. Non-rectangular (jagged) matrices could lead to runtime errors or incorrect behavior since the expectation for movement between cells would be ambiguous or undefined.", "4, Performance Expectations Undefined: There are no specifications or constraints provided about the expected matrix size or time/space complexity requirements. This omission can lead to solutions that are inefficient for large datasets, potentially causing performance issues in real-world applications or competitive scenarios."]}}
